---
title: 闭包的考查
date: 2020-09-04 20:24:04
categories:
    - JavaScript
tags:
    - 面试题
---
关于闭包的考查部分题目如下：
<!--more-->
首先抛出一个问题
- 你理解的闭包是什么？优缺点有哪些？
    1. 保护： 形成一个私有作用域，保护里面私有变量不受外界干扰
    2. 保存： 形成一个不销毁的栈内存，把所需要的变量保存起来以便后续使用
    -  缺点： 形成不销毁的栈内存，比较耗性能
1. 输出代码结果
```javascript
console.log(a)
var a = 12
function fn(){
    console.log(a)
    var a = 13 // 若此处去掉var，则答案选A
}
fn()
console.log(a)
/**
 * A、undefined, 12, 13
 * B、undefined, undefined, 12
 * C、undefined, undefined, 13
 * D、有程序报错
/
/**
 * 答案选B
 * 1，变量提升
 * 2，顺序执行
 * 3，执行fn，形成一个私有作用域=》形参赋值，变量提升，顺序执行
/
```
2. 输出代码结果
```javascript
var foo = 1
function bar(){
    if(!foo){ // 不管条件是否成立，都要进行变量提示
        var foo = 10
    }
    console.log(foo)
}
bar()
/**
 * 答案选B 变量提升后foo= undefined，条件为true
 * A、1
 * B、10
 * C、undefined
 * D、报错
/
```
3. 输出代码结果
```javascript
// => 全局下的变量提升var n,var c, a=AAAFFF
var n = 0
function a(){
    // 私有作用域，形参赋值：无，变量提升：var n， b=BBBFFF
    var n = 10 //  n=> 11 n=> 12
    function b(){
        // 私有作用域
        n++ // n为上级作用域的
        console.log(n)
    }
    b() // 输出11
    return b // return BBBFFF
}
var c = a() // c为BBBFFF，此时a函数中的私有作用域不销毁
c() //再次执行BBBFFF n=>12
console.log(n) // 输出全局n， 即 0
/**
 * 选C
 * A、1 1 1
 * B、11 11 0
 * C、11 12 0
 * D、11 12 12
/
```
4. 输出代码结果
```javascript
// 全局下的变量提升var a, var b, var c, 声明并定义test = AAAFFF
var a = 10, b = 11, c = 12
function test(a){
    // 私有作用域a=10，var b 
    a = 1 // 私有a由10变为1
    var b = 2 // 私有b=2
    c = 3  // 全局c由12变为3
}
test(10)
console.log(a) // 全局a = 10
console.log(b) // 全局b = 11
console.log(c) // 全局c = 3
```
5. 输出代码结果
```javascript
// 首先不管条件是否成立，都要进行变量提升
if(!('a' in window)){ // 变量提升后window.a = undefined => 'a' in window 为true
    var a = 1 // a = 1 未执行
}
console.log(a) // undefined
```
6. 输出代码结果
```javascript
// 全局变量提升 var a, 声明及定义b=BBBFFF
var a = 4
function b(x, y, a){
    // 执行b形成私有作用域x=1,y=2,a=3
    console.log(a) // 私有a=3
    arguments[2] = 10 // 非严格模式下，arguments和形参有映射关系 a 变为 10
    console.log(a) // 私有a=10
}
a = b(1, 2, 3) // b函数没有返回值，此时a为undefined
console.log(a) // 全局a变为undefined
```
7. 输出代码结果
```javascript
// 全局变量提升 var a, var f, fn = AAAFFF
var a = 9
function fn(){
    a = 0 // 执行fn形成私有作用域，全局a变为0， return BBBFFF
    return function(b){
        return b + a++
    }
}
var f = fn() // 不销毁
console.log(f(5)) // 5+a++ => 5+0++ => 5 // 此时全局a变为1 BBBFFF111销毁 AAAFFF不销毁
console.log(fn()(5)) // fn重新开辟空间并执行，a重置为0=> fn()(5) => 5+0++ => 5 // 此时a为1 fn=AAAFFF临时不销毁，等fn()()即BBBFFF222执行完毕后再销毁
console.log(f(5)) // 5+a++ => 5+1++ => 6 // 此时a为2 BBBFFF222销毁 AAAFFF不销毁
```
8. 输出代码结果
```javascript
// 全局变量提升var ary = AAAFFF111, var res, fn = AAAFFF222
var ary = [1, 2, 3, 4]
function fn(ary){
    // 将ary的地址赋值给形参， 私有ary和全局ary指向同一个内存空间。没有直接关系，但是存在间接关系
    ary[0] = 0 // 私有ary = [0, 2, 3, 4] =>全局ary的值也同时被改变
    ary = [0] // 私有ary重新开辟空间 ary = [0]，此时的ary与全局ary无任何关联
    ary[0] = 100 // 私有ary重新赋值 ary = [100]
    return ary // 返回私有ary = [100]
}
var res = fn(ary)
console.log(ary) // 全局ary = [0, 2, 3, 4]
console.log(res) // ary = [100]
```
9. 输出代码结果
```javascript
function fn(i){
    return function(n){
        console.log(n+(--i))
    }
}
var f = fn(2) // 不销毁
f(3)//4  不销毁  i变为了1
fn(4)(5)//8 重新形参赋值，开辟空间
fn(6)(7)//12 重新形参赋值，开辟空间
f(8)//8  不销毁  i变为了0
// 此题与第7题类似
```
10. 输出代码结果
```javascript
// 全局变量提升var num,var obj, var fn
var num = 10
var obj = { num: 20 } // 开辟空间
obj.fn = (function (num){ // 添加属性fn=
    this.num = num*3 // this: window =>windwow.num = 60
    num++ // => num = 21
    return function(n){ //开辟空间BBBFFF111
        this.num += n
        num++ // 让上级作用域中num++ => 22
        console.log(num)
    }
})(obj.num)
var fn = obj.fn // BBBFFF111 不销毁
fn(5) // window.num = window.num+5 => window.num = 60+5 = 65
obj.fn(10) // this: obj => num+=n => num = 30 // num++ => 23
console.log(num, obj.num) // 65 30 
```