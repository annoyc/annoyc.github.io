<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>面经(yz)</title>
      <link href="/2020/09/01/%E9%9D%A2%E7%BB%8F-yz/"/>
      <url>/2020/09/01/%E9%9D%A2%E7%BB%8F-yz/</url>
      
        <content type="html"><![CDATA[<p>yz某公司部分面试题，学习记录如下</p><a id="more"></a><ol><li>svg是什么？<ul><li>SVG 意为可缩放矢量图形（Scalable Vector Graphics）。</li><li>SVG 使用 XML 格式定义图像。</li></ul></li><li>什么情况下用vuex？<ul><li>多个组件间需要传递参数或状态时</li><li>较大型项目使用</li></ul></li><li>vue本身的更新机制了解吗？ <ul><li>Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。</li><li>简单来说，Vue 在修改数据后，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新。</li><li>同步里执行的方法，每个方法里做的事情组成一个事件循环；接下来再次调用的是另一个事件循环。</li><li>nextTick：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，会获取更新后的 DOM。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//改变数据</span></span><br><span class="line">vm.message = <span class="string">'changed'</span></span><br><span class="line"><span class="comment">//想要立即使用更新后的DOM。这样不行，因为设置message后DOM还没有更新</span></span><br><span class="line"><span class="built_in">console</span>.log(vm.$el.textContent) <span class="comment">// 并不会得到'changed'</span></span><br><span class="line"><span class="comment">//这样可以，nextTick里面的代码会在DOM更新后执行</span></span><br><span class="line">Vue.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(vm.$el.textContent) <span class="comment">//可以得到'changed'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li><li>computed和watch的了解？<ul><li>computed 本质是一个惰性求值的观察者，具有缓存性，只有当依赖变化后，第一次访问 computed 属性，才会计算新的值，而 watch 则是当数据发生变化便会调用执行函数</li><li>从使用场景上说，computed 适用一个数据被多个数据影响，而 watch 适用一个数据影响多个数据;</li></ul></li><li>observer和watcher的了解？<ul><li>Vue 响应系统，其核心有三点：observe、watcher、dep：<ul><li>observe：遍历 data 中的属性，使用 Object.defineProperty 的 get/set 方法对其进行数据劫持；</li><li>dep：每个属性拥有自己的消息订阅器 dep，用于存放所有订阅了该属性的观察者对象；</li><li>watcher：观察者（对象），通过 dep 实现对响应属性的监听，监听到结果后，主动触发自己的回调进行响应。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手动注销watch</span></span><br><span class="line"><span class="keyword">const</span> unwatch = app.$watch(<span class="string">'text'</span>, &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val);</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    deep: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li>vue3.0有什么特性？<ul><li><a href="https://www.cnblogs.com/Rivend/p/12630779.html" target="_blank" rel="noopener">此链接内容可供参考</a></li></ul></li><li>vue中的Object.defineProperty()有什么缺陷？<ul><li>Object.defineProperty无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应；</li><li>Object.defineProperty只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍。Proxy可以劫持整个对象，并返回一个新的对象。</li><li>Proxy不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性。</li></ul></li><li>var与let、const的区别<ul><li>var声明变量存在变量提升，let和const不存在变量提升， window可以访问到var声明的值</li><li>let、const都是块级局部变量</li><li>同一作用域下let和const不能声明同名变量，而var可以</li></ul></li><li>什么是块级作用域？<ul><li>JS中作用域有：全局作用域、函数作用域。没有块作用域的概念。ECMAScript 6(简称ES6)中新增了块级作用域。块作用域由 {} 包括，if语句和for语句里面的{}也属于块作用域。</li></ul></li><li>js中的class是怎么实现的？<ul><li><a href="https://blog.csdn.net/weixin_33681778/article/details/88038531" target="_blank" rel="noopener">此链接内容可供参考</a></li></ul></li><li>js基础类型和引用类型<ul><li>es5中基础类型包括：number，string，null，undefined，Boolean。es6新增了一种基础类型symbol,基础类型的存储是存放在栈中，原因是基础类型存储的空间很小，存放在栈（stack）中方便查找，且不易于改变</li><li>引用类型是指有多个值构成的对象，也就是对象类型比如：Object,Array,Function,Data等，js的引用数据类型是存储在堆中（heap），也就是说存储的变量处的值是一个指针（point），指向存储对象的内存地址。存在堆中的原因是：引用值的大小会改变，所以不能放在栈中，否则会降低变量查询的速度</li></ul></li><li>哪些方法判断值的类型？<ul><li><a href="https://www.jianshu.com/p/967d6db70437" target="_blank" rel="noopener">此链接内容可供参考</a></li></ul><ol><li>typeof 运算符</li><li>instanceof</li><li>通过Object下的toString.call()方法来判断</li><li>根据对象的contructor判断</li></ol></li><li>instance of底层实现机制<ul><li>只要右边变量的 prototype 在左边变量的原型链上即可。因此，instanceof 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 prototype，如果查找失败，则会返回 false</li></ul></li><li>水平居中的几种方式<ul><li><a href="https://blog.csdn.net/weixin_42291381/article/details/81624935" target="_blank" rel="noopener">此链接内容可供参考</a></li></ul></li><li>BFC(block formatting context)<ul><li><a href="https://zhuanlan.zhihu.com/p/25321647" target="_blank" rel="noopener">此链接内容可供参考</a></li><li>使 BFC 内部浮动元素不会到处乱跑</li><li>和浮动元素产生边界</li></ul></li><li>如何创建BFC<ol><li>float的值不是none。</li><li>position的值不是static或者relative。</li><li>display的值是inline-block、table-cell、flex、table-caption或者inline-flex</li><li>overflow的值不是visible</li></ol></li><li>触发 BFC<ul><li>只要元素满足下面任一条件即可触发 BFC 特性：<ul><li>body 根元素</li><li>浮动元素：float 除 none 以外的值</li><li>绝对定位元素：position (absolute、fixed)</li><li>display 为 inline-block、table-cells、flex</li><li>overflow 除了 visible 以外的值 (hidden、auto、scroll)</li></ul></li></ul></li><li>流式布局<ul><li><a href="https://www.cnblogs.com/zylseo/p/12599443.html" target="_blank" rel="noopener">此链接内容可供参考</a></li><li><a href="https://www.jianshu.com/p/4a6e5162e4ee" target="_blank" rel="noopener">此链接内容可供参考</a></li></ul></li><li>css的选择器和对应的优先级<ul><li><a href="https://blog.csdn.net/b954960630/article/details/79560590" target="_blank" rel="noopener">此链接内容可供参考</a></li><li>!important &gt; 行内样式&gt;ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性</li></ul></li><li>移动端自适应布局与字体大小自适应<ul><li><a href="https://blog.csdn.net/w390058785/article/details/80562776" target="_blank" rel="noopener">此链接内容可供参考</a></li><li>vw, vh</li><li>用js去计算并设置html标签的font-size大小</li></ul></li><li>em和rem的区别<ul><li>rem 单位翻译为像素值是由 html 元素的字体大小决定的。 此字体大小会被浏览器中字体大小的设置影响，除非显式重写一个具体单位</li><li>em 单位转为像素值，取决于他们使用的字体大小。 此字体大小受从父元素继承过来的字体大小，除非显式重写与一个具体单位</li></ul></li><li>数组遍历方法<ul><li><a href="https://www.cnblogs.com/QuietWinter/p/9115855.html" target="_blank" rel="noopener">此链接内容可供参考</a></li></ul></li><li>post和get<ul><li>Get产生一个TCP数据包；Post产生两个TCP数据包。</li><li>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；对于POST，浏览器先发送header，服务器响应100（continue），然后再发送data，服务器响应200（返回数据）；</li><li>GET幂等，POST不幂等(幂等是指同一个请求方法执行多次和仅执行一次的效果完全相同。)</li></ul></li><li>强制缓存和协商缓存<ul><li><a href="https://blog.csdn.net/zl399615007/article/details/84534884?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param" target="_blank" rel="noopener">此链接内容可供参考</a></li></ul></li><li>http头部字段有哪些？<ul><li><a href="https://www.cnblogs.com/soldierback/p/11714052.html" target="_blank" rel="noopener">此链接内容可供参考</a></li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么需要node作为中间层</title>
      <link href="/2020/09/01/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81node%E4%BD%9C%E4%B8%BA%E4%B8%AD%E9%97%B4%E5%B1%82/"/>
      <url>/2020/09/01/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81node%E4%BD%9C%E4%B8%BA%E4%B8%AD%E9%97%B4%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<p>通常我们把Web领域分为客户端和服务端，也就是前端和后端，这里的后端就包含了网关，静态资源，接口，缓存，数据库等。而中间层呢，就是在后端这里再抽离一层出来，在业务上处理和客户端衔接更紧密的部分，比如页面渲染（SSR），数据聚合，接口转发等等。<br>以SSR来说，在服务端将页面渲染好，可以加快用户的首屏加载速度，避免请求时白屏，还有利于网站做SEO，他的好处是比较好理解的。那么对于数据的聚合，接口转发来说，这样做有什么意义呢？</p><a id="more"></a><ul><li>用Node的原因有以下：<ul><li>代理：在开发环境下，我们可以利用代理来，解决最常见的跨域问题；在线上环境下，我们可以利用代理，转发请求到多个服务端</li><li>缓存：缓存其实是更靠近前端的需求，用户的动作触发数据的更新，node中间层可以直接处理一部分缓存需求。</li><li>限流：node中间层，可以针对接口或者路由做响应的限流。</li><li>日志：相比其他服务端语言，node中间层的日志记录，能更方便快捷的定位问题（是在浏览器端还是服务端）。</li><li>监控：擅长高并发的请求处理，做监控也是合适的选项。</li><li>鉴权：有一个中间层去鉴权，也是一种单一职责的实现。</li><li>路由：前端更需要掌握页面路由的权限和逻辑。</li><li>服务端渲染：node中间层的解决方案更灵活，比如SSR、模板直出、利用一些JS库做预渲染等等。</li><li>更多的可能性</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/05/07/hello-world/"/>
      <url>/2020/05/07/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
