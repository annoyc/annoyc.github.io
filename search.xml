<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2020/05/07/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么需要node作为中间层</title>
    <url>/2020/09/01/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81node%E4%BD%9C%E4%B8%BA%E4%B8%AD%E9%97%B4%E5%B1%82/</url>
    <content><![CDATA[<p>通常我们把Web领域分为客户端和服务端，也就是前端和后端，这里的后端就包含了网关，静态资源，接口，缓存，数据库等。而中间层呢，就是在后端这里再抽离一层出来，在业务上处理和客户端衔接更紧密的部分，比如页面渲染（SSR），数据聚合，接口转发等等。<br>以SSR来说，在服务端将页面渲染好，可以加快用户的首屏加载速度，避免请求时白屏，还有利于网站做SEO，他的好处是比较好理解的。那么对于数据的聚合，接口转发来说，这样做有什么意义呢？</p>
<a id="more"></a>
<ul>
<li>用Node的原因有以下：<ul>
<li>代理：在开发环境下，我们可以利用代理来，解决最常见的跨域问题；在线上环境下，我们可以利用代理，转发请求到多个服务端</li>
<li>缓存：缓存其实是更靠近前端的需求，用户的动作触发数据的更新，node中间层可以直接处理一部分缓存需求。</li>
<li>限流：node中间层，可以针对接口或者路由做响应的限流。</li>
<li>日志：相比其他服务端语言，node中间层的日志记录，能更方便快捷的定位问题（是在浏览器端还是服务端）。</li>
<li>监控：擅长高并发的请求处理，做监控也是合适的选项。</li>
<li>鉴权：有一个中间层去鉴权，也是一种单一职责的实现。</li>
<li>路由：前端更需要掌握页面路由的权限和逻辑。</li>
<li>服务端渲染：node中间层的解决方案更灵活，比如SSR、模板直出、利用一些JS库做预渲染等等。</li>
<li>更多的可能性</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>面经(yz)</title>
    <url>/2020/09/01/%E9%9D%A2%E7%BB%8F-yz/</url>
    <content><![CDATA[<p>yz某公司部分面试题，学习记录如下</p>
<a id="more"></a>
<ol>
<li>svg是什么？<ul>
<li>SVG 意为可缩放矢量图形（Scalable Vector Graphics）。</li>
<li>SVG 使用 XML 格式定义图像。</li>
</ul>
</li>
<li>什么情况下用vuex？<ul>
<li>多个组件间需要传递参数或状态时</li>
<li>较大型项目使用</li>
</ul>
</li>
<li>vue本身的更新机制了解吗？ <ul>
<li>Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。</li>
<li>简单来说，Vue 在修改数据后，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新。</li>
<li>同步里执行的方法，每个方法里做的事情组成一个事件循环；接下来再次调用的是另一个事件循环。</li>
<li>nextTick：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，会获取更新后的 DOM。 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//改变数据</span></span><br><span class="line">vm.message = <span class="string">'changed'</span></span><br><span class="line"><span class="comment">//想要立即使用更新后的DOM。这样不行，因为设置message后DOM还没有更新</span></span><br><span class="line"><span class="built_in">console</span>.log(vm.$el.textContent) <span class="comment">// 并不会得到'changed'</span></span><br><span class="line"><span class="comment">//这样可以，nextTick里面的代码会在DOM更新后执行</span></span><br><span class="line">Vue.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(vm.$el.textContent) <span class="comment">//可以得到'changed'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>computed和watch的了解？<ul>
<li>computed 本质是一个惰性求值的观察者，具有缓存性，只有当依赖变化后，第一次访问 computed 属性，才会计算新的值，而 watch 则是当数据发生变化便会调用执行函数</li>
<li>从使用场景上说，computed 适用一个数据被多个数据影响，而 watch 适用一个数据影响多个数据;</li>
</ul>
</li>
<li>observer和watcher的了解？<ul>
<li>Vue 响应系统，其核心有三点：observe、watcher、dep：<ul>
<li>observe：遍历 data 中的属性，使用 Object.defineProperty 的 get/set 方法对其进行数据劫持；</li>
<li>dep：每个属性拥有自己的消息订阅器 dep，用于存放所有订阅了该属性的观察者对象；</li>
<li>watcher：观察者（对象），通过 dep 实现对响应属性的监听，监听到结果后，主动触发自己的回调进行响应。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 手动注销watch</span></span><br><span class="line"><span class="keyword">const</span> unwatch = app.$watch(<span class="string">'text'</span>, &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val);</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    deep: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>vue3.0有什么特性？<ul>
<li><a href="https://www.cnblogs.com/Rivend/p/12630779.html" target="_blank" rel="noopener">此链接内容可供参考</a></li>
</ul>
</li>
<li>vue中的Object.defineProperty()有什么缺陷？<ul>
<li>Object.defineProperty无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应；</li>
<li>Object.defineProperty只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍。Proxy可以劫持整个对象，并返回一个新的对象。</li>
<li>Proxy不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性。</li>
</ul>
</li>
<li>var与let、const的区别<ul>
<li>var声明变量存在变量提升，let和const不存在变量提升， window可以访问到var声明的值</li>
<li>let、const都是块级局部变量</li>
<li>同一作用域下let和const不能声明同名变量，而var可以</li>
</ul>
</li>
<li>什么是块级作用域？<ul>
<li>JS中作用域有：全局作用域、函数作用域。没有块作用域的概念。ECMAScript 6(简称ES6)中新增了块级作用域。块作用域由 {} 包括，if语句和for语句里面的{}也属于块作用域。</li>
</ul>
</li>
<li>js中的class是怎么实现的？<ul>
<li><a href="https://blog.csdn.net/weixin_33681778/article/details/88038531" target="_blank" rel="noopener">此链接内容可供参考</a></li>
</ul>
</li>
<li>js基础类型和引用类型<ul>
<li>es5中基础类型包括：number，string，null，undefined，Boolean。es6新增了一种基础类型symbol,基础类型的存储是存放在栈中，原因是基础类型存储的空间很小，存放在栈（stack）中方便查找，且不易于改变</li>
<li>引用类型是指有多个值构成的对象，也就是对象类型比如：Object,Array,Function,Data等，js的引用数据类型是存储在堆中（heap），也就是说存储的变量处的值是一个指针（point），指向存储对象的内存地址。存在堆中的原因是：引用值的大小会改变，所以不能放在栈中，否则会降低变量查询的速度</li>
</ul>
</li>
<li>哪些方法判断值的类型？<ul>
<li><a href="https://www.jianshu.com/p/967d6db70437" target="_blank" rel="noopener">此链接内容可供参考</a></li>
</ul>
<ol>
<li>typeof 运算符</li>
<li>instanceof</li>
<li>通过Object下的toString.call()方法来判断</li>
<li>根据对象的contructor判断</li>
</ol>
</li>
<li>instance of底层实现机制<ul>
<li>只要右边变量的 prototype 在左边变量的原型链上即可。因此，instanceof 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 prototype，如果查找失败，则会返回 false</li>
</ul>
</li>
<li>水平居中的几种方式<ul>
<li><a href="https://blog.csdn.net/weixin_42291381/article/details/81624935" target="_blank" rel="noopener">此链接内容可供参考</a></li>
</ul>
</li>
<li>BFC(block formatting context)<ul>
<li><a href="https://zhuanlan.zhihu.com/p/25321647" target="_blank" rel="noopener">此链接内容可供参考</a></li>
<li>使 BFC 内部浮动元素不会到处乱跑</li>
<li>和浮动元素产生边界</li>
</ul>
</li>
<li>如何创建BFC<ol>
<li>float的值不是none。</li>
<li>position的值不是static或者relative。</li>
<li>display的值是inline-block、table-cell、flex、table-caption或者inline-flex</li>
<li>overflow的值不是visible</li>
</ol>
</li>
<li>触发 BFC<ul>
<li>只要元素满足下面任一条件即可触发 BFC 特性：<ul>
<li>body 根元素</li>
<li>浮动元素：float 除 none 以外的值</li>
<li>绝对定位元素：position (absolute、fixed)</li>
<li>display 为 inline-block、table-cells、flex</li>
<li>overflow 除了 visible 以外的值 (hidden、auto、scroll)</li>
</ul>
</li>
</ul>
</li>
<li>流式布局<ul>
<li><a href="https://www.cnblogs.com/zylseo/p/12599443.html" target="_blank" rel="noopener">此链接内容可供参考</a></li>
<li><a href="https://www.jianshu.com/p/4a6e5162e4ee" target="_blank" rel="noopener">此链接内容可供参考</a></li>
</ul>
</li>
<li>css的选择器和对应的优先级<ul>
<li><a href="https://blog.csdn.net/b954960630/article/details/79560590" target="_blank" rel="noopener">此链接内容可供参考</a></li>
<li>!important &gt; 行内样式&gt;ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性</li>
</ul>
</li>
<li>移动端自适应布局与字体大小自适应<ul>
<li><a href="https://blog.csdn.net/w390058785/article/details/80562776" target="_blank" rel="noopener">此链接内容可供参考</a></li>
<li>vw, vh</li>
<li>用js去计算并设置html标签的font-size大小</li>
</ul>
</li>
<li>em和rem的区别<ul>
<li>rem 单位翻译为像素值是由 html 元素的字体大小决定的。 此字体大小会被浏览器中字体大小的设置影响，除非显式重写一个具体单位</li>
<li>em 单位转为像素值，取决于他们使用的字体大小。 此字体大小受从父元素继承过来的字体大小，除非显式重写与一个具体单位</li>
</ul>
</li>
<li>数组遍历方法<ul>
<li><a href="https://www.cnblogs.com/QuietWinter/p/9115855.html" target="_blank" rel="noopener">此链接内容可供参考</a></li>
</ul>
</li>
<li>post和get<ul>
<li>Get产生一个TCP数据包；Post产生两个TCP数据包。</li>
<li>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；对于POST，浏览器先发送header，服务器响应100（continue），然后再发送data，服务器响应200（返回数据）；</li>
<li>GET幂等，POST不幂等(幂等是指同一个请求方法执行多次和仅执行一次的效果完全相同。)</li>
</ul>
</li>
<li>强制缓存和协商缓存<ul>
<li><a href="https://blog.csdn.net/zl399615007/article/details/84534884?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param" target="_blank" rel="noopener">此链接内容可供参考</a></li>
</ul>
</li>
<li>http头部字段有哪些？<ul>
<li><a href="https://www.cnblogs.com/soldierback/p/11714052.html" target="_blank" rel="noopener">此链接内容可供参考</a></li>
</ul>
</li>
<li>首页一个sleep函数（可从Promise，Generator，async/await等角度实现）<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">ms</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span>&#123;</span><br><span class="line">        setTimeout(resolve, ms)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">~<span class="function">(<span class="params"><span class="keyword">async</span> (</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">111</span>)</span><br><span class="line">    <span class="keyword">await</span> sleep(<span class="number">2000</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">222</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>面经(虾皮)</title>
    <url>/2020/09/04/%E9%9D%A2%E7%BB%8F-%E8%99%BE%E7%9A%AE/</url>
    <content><![CDATA[<p>以下为虾皮一面部分面试题:</p>
<a id="more"></a>
<ol>
<li>输出以下结果<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = <span class="string">'Parent'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Tom</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = <span class="string">'Tom'</span></span><br><span class="line">&#125;</span><br><span class="line">Parent.__proto__.print = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// Parent.__proto__实际上指向Object.prototype</span></span><br><span class="line">    <span class="keyword">this</span>.a = <span class="number">4</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line">Parent.print() <span class="comment">// 4</span></span><br><span class="line">Tom.print() <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Parent()</span><br><span class="line"><span class="built_in">console</span>.log(child.a) <span class="comment">// Parent</span></span><br><span class="line">child.print() <span class="comment">// 报错 child.print is not a function</span></span><br></pre></td></tr></table></figure></li>
<li>f能不能拿到a方法和b方法？<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.prototype.a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="built_in">Function</span>.prototype.b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> F();</span><br><span class="line"><span class="comment">// f最终指向为Object的prototype，所有只能拿到a方法</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>回流和重绘</title>
    <url>/2020/09/05/%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98/</url>
    <content><![CDATA[<p>网页的回流和重绘知识点如下：</p>
<a id="more"></a>
<ol>
<li><strong>回流</strong><br>回流又称之为<strong>重排</strong>，当Render Tree中的一部分（或者全部）因元素的规模，尺寸，布局等改变，而需要重新构建页面，就会触发回流<br>具体总结为：<ul>
<li>页面初始渲染</li>
<li>添加、删除可见的DOM元素</li>
<li>改变元素位置，尺寸，内容<br>触发回流的属性：</li>
<li>盒子模型相关属性：width、height、display、border、border-width…</li>
<li>定位及浮动：position、left、right、top、bottom、float、padding、margin…</li>
<li>文字相关：text-align、overflow、font-weight、font-family、line-height，vertical-align、font-size、white-space…</li>
</ul>
</li>
<li><strong>重绘</strong><br>当Render Tree中的一些元素需要更新属性，而这些属性只是影响到元素的外观，风格而不影响布局，就会触发重绘<br><strong>回流一定重绘，但是重绘不一定回流</strong><br>触发重绘的属性：<ul>
<li>color、border-style、border-radius、outline、visibility、background-color、text-decoration、background、background-image、box-shadow…</li>
</ul>
</li>
<li>如何减少回流和重绘<ul>
<li>用translate代替top</li>
<li>用opacity代替visibility</li>
<li>预先定义好className，然后统一修改Dom的className</li>
<li>不要把Dom结点的属性值放在一个循环里面变成循环变量</li>
<li>让要操作的元素进行“离线处理”，处理完后一起更新</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>闭包的考查</title>
    <url>/2020/09/04/%E9%97%AD%E5%8C%85%E7%9A%84%E8%80%83%E6%9F%A5/</url>
    <content><![CDATA[<p>关于闭包的考查部分题目如下：</p>
<a id="more"></a>
<p>首先抛出一个问题</p>
<ul>
<li>你理解的闭包是什么？优缺点有哪些？<ol>
<li>保护： 形成一个私有作用域，保护里面私有变量不受外界干扰</li>
<li>保存： 形成一个不销毁的栈内存，把所需要的变量保存起来以便后续使用</li>
</ol>
<ul>
<li>缺点： 形成不销毁的栈内存，比较耗性能</li>
</ul>
</li>
</ul>
<ol>
<li>输出代码结果<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">12</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">13</span> <span class="comment">// 若此处去掉var，则答案选A</span></span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A、undefined, 12, 13</span></span><br><span class="line"><span class="comment"> * B、undefined, undefined, 12</span></span><br><span class="line"><span class="comment"> * C、undefined, undefined, 13</span></span><br><span class="line"><span class="comment"> * D、有程序报错</span></span><br><span class="line"><span class="comment">/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 答案选B</span></span><br><span class="line"><span class="comment"> * 1，变量提升</span></span><br><span class="line"><span class="comment"> * 2，顺序执行</span></span><br><span class="line"><span class="comment"> * 3，执行fn，形成一个私有作用域=》形参赋值，变量提升，顺序执行</span></span><br><span class="line"><span class="comment">/</span></span><br></pre></td></tr></table></figure></li>
<li>输出代码结果<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!foo)&#123; <span class="comment">// 不管条件是否成立，都要进行变量提示</span></span><br><span class="line">        <span class="keyword">var</span> foo = <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(foo)</span><br><span class="line">&#125;</span><br><span class="line">bar()</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 答案选B 变量提升后foo= undefined，条件为true</span></span><br><span class="line"><span class="comment"> * A、1</span></span><br><span class="line"><span class="comment"> * B、10</span></span><br><span class="line"><span class="comment"> * C、undefined</span></span><br><span class="line"><span class="comment"> * D、报错</span></span><br><span class="line"><span class="comment">/</span></span><br></pre></td></tr></table></figure></li>
<li>输出代码结果<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// =&gt; 全局下的变量提升var n,var c, a=AAAFFF</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 私有作用域，形参赋值：无，变量提升：var n， b=BBBFFF</span></span><br><span class="line">    <span class="keyword">var</span> n = <span class="number">10</span> <span class="comment">//  n=&gt; 11 n=&gt; 12</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 私有作用域</span></span><br><span class="line">        n++ <span class="comment">// n为上级作用域的</span></span><br><span class="line">        <span class="built_in">console</span>.log(n)</span><br><span class="line">    &#125;</span><br><span class="line">    b() <span class="comment">// 输出11</span></span><br><span class="line">    <span class="keyword">return</span> b <span class="comment">// return BBBFFF</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c = a() <span class="comment">// c为BBBFFF，此时a函数中的私有作用域不销毁</span></span><br><span class="line">c() <span class="comment">//再次执行BBBFFF n=&gt;12</span></span><br><span class="line"><span class="built_in">console</span>.log(n) <span class="comment">// 输出全局n， 即 0</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选C</span></span><br><span class="line"><span class="comment"> * A、1 1 1</span></span><br><span class="line"><span class="comment"> * B、11 11 0</span></span><br><span class="line"><span class="comment"> * C、11 12 0</span></span><br><span class="line"><span class="comment"> * D、11 12 12</span></span><br><span class="line"><span class="comment">/</span></span><br></pre></td></tr></table></figure></li>
<li>输出代码结果<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局下的变量提升var a, var b, var c, 声明并定义test = AAAFFF</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>, b = <span class="number">11</span>, c = <span class="number">12</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 私有作用域a=10，var b </span></span><br><span class="line">    a = <span class="number">1</span> <span class="comment">// 私有a由10变为1</span></span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">2</span> <span class="comment">// 私有b=2</span></span><br><span class="line">    c = <span class="number">3</span>  <span class="comment">// 全局c由12变为3</span></span><br><span class="line">&#125;</span><br><span class="line">test(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 全局a = 10</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// 全局b = 11</span></span><br><span class="line"><span class="built_in">console</span>.log(c) <span class="comment">// 全局c = 3</span></span><br></pre></td></tr></table></figure></li>
<li>输出代码结果<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先不管条件是否成立，都要进行变量提升</span></span><br><span class="line"><span class="keyword">if</span>(!(<span class="string">'a'</span> <span class="keyword">in</span> <span class="built_in">window</span>))&#123; <span class="comment">// 变量提升后window.a = undefined =&gt; 'a' in window 为true</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span> <span class="comment">// a = 1 未执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li>
<li>输出代码结果<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局变量提升 var a, 声明及定义b=BBBFFF</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">4</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params">x, y, a</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 执行b形成私有作用域x=1,y=2,a=3</span></span><br><span class="line">    <span class="built_in">console</span>.log(a) <span class="comment">// 私有a=3</span></span><br><span class="line">    <span class="built_in">arguments</span>[<span class="number">2</span>] = <span class="number">10</span> <span class="comment">// 非严格模式下，arguments和形参有映射关系 a 变为 10</span></span><br><span class="line">    <span class="built_in">console</span>.log(a) <span class="comment">// 私有a=10</span></span><br><span class="line">&#125;</span><br><span class="line">a = b(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// b函数没有返回值，此时a为undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 全局a变为undefined</span></span><br></pre></td></tr></table></figure></li>
<li>输出代码结果<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局变量提升 var a, var f, fn = AAAFFF</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">9</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    a = <span class="number">0</span> <span class="comment">// 执行fn形成私有作用域，全局a变为0， return BBBFFF</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">b</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b + a++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = fn() <span class="comment">// 不销毁</span></span><br><span class="line"><span class="built_in">console</span>.log(f(<span class="number">5</span>)) <span class="comment">// 5+a++ =&gt; 5+0++ =&gt; 5 // 此时全局a变为1 BBBFFF111销毁 AAAFFF不销毁</span></span><br><span class="line"><span class="built_in">console</span>.log(fn()(<span class="number">5</span>)) <span class="comment">// fn重新开辟空间并执行，a重置为0=&gt; fn()(5) =&gt; 5+0++ =&gt; 5 // 此时a为1 fn=AAAFFF临时不销毁，等fn()()即BBBFFF222执行完毕后再销毁</span></span><br><span class="line"><span class="built_in">console</span>.log(f(<span class="number">5</span>)) <span class="comment">// 5+a++ =&gt; 5+1++ =&gt; 6 // 此时a为2 BBBFFF222销毁 AAAFFF不销毁</span></span><br></pre></td></tr></table></figure></li>
<li>输出代码结果<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局变量提升var ary = AAAFFF111, var res, fn = AAAFFF222</span></span><br><span class="line"><span class="keyword">var</span> ary = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">ary</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 将ary的地址赋值给形参， 私有ary和全局ary指向同一个内存空间。没有直接关系，但是存在间接关系</span></span><br><span class="line">    ary[<span class="number">0</span>] = <span class="number">0</span> <span class="comment">// 私有ary = [0, 2, 3, 4] =&gt;全局ary的值也同时被改变</span></span><br><span class="line">    ary = [<span class="number">0</span>] <span class="comment">// 私有ary重新开辟空间 ary = [0]，此时的ary与全局ary无任何关联</span></span><br><span class="line">    ary[<span class="number">0</span>] = <span class="number">100</span> <span class="comment">// 私有ary重新赋值 ary = [100]</span></span><br><span class="line">    <span class="keyword">return</span> ary <span class="comment">// 返回私有ary = [100]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> res = fn(ary)</span><br><span class="line"><span class="built_in">console</span>.log(ary) <span class="comment">// 全局ary = [0, 2, 3, 4]</span></span><br><span class="line"><span class="built_in">console</span>.log(res) <span class="comment">// ary = [100]</span></span><br></pre></td></tr></table></figure></li>
<li>输出代码结果<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(n+(--i))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = fn(<span class="number">2</span>) <span class="comment">// 不销毁</span></span><br><span class="line">f(<span class="number">3</span>)<span class="comment">//4  不销毁  i变为了1</span></span><br><span class="line">fn(<span class="number">4</span>)(<span class="number">5</span>)<span class="comment">//8 重新形参赋值，开辟空间</span></span><br><span class="line">fn(<span class="number">6</span>)(<span class="number">7</span>)<span class="comment">//12 重新形参赋值，开辟空间</span></span><br><span class="line">f(<span class="number">8</span>)<span class="comment">//8  不销毁  i变为了0</span></span><br><span class="line"><span class="comment">// 此题与第7题类似</span></span><br></pre></td></tr></table></figure></li>
<li>输出代码结果<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局变量提升var num,var obj, var fn</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">num</span>: <span class="number">20</span> &#125; <span class="comment">// 开辟空间</span></span><br><span class="line">obj.fn = (<span class="function"><span class="keyword">function</span> (<span class="params">num</span>)</span>&#123; <span class="comment">// 添加属性fn=</span></span><br><span class="line">    <span class="keyword">this</span>.num = num*<span class="number">3</span> <span class="comment">// this: window =&gt;windwow.num = 60</span></span><br><span class="line">    num++ <span class="comment">// =&gt; num = 21</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123; <span class="comment">//开辟空间BBBFFF111</span></span><br><span class="line">        <span class="keyword">this</span>.num += n</span><br><span class="line">        num++ <span class="comment">// 让上级作用域中num++ =&gt; 22</span></span><br><span class="line">        <span class="built_in">console</span>.log(num)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(obj.num)</span><br><span class="line"><span class="keyword">var</span> fn = obj.fn <span class="comment">// BBBFFF111 不销毁</span></span><br><span class="line">fn(<span class="number">5</span>) <span class="comment">// window.num = window.num+5 =&gt; window.num = 60+5 = 65</span></span><br><span class="line">obj.fn(<span class="number">10</span>) <span class="comment">// this: obj =&gt; num+=n =&gt; num = 30 // num++ =&gt; 23</span></span><br><span class="line"><span class="built_in">console</span>.log(num, obj.num) <span class="comment">// 65 30</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>多个按钮单击事件</title>
    <url>/2020/09/05/%E5%A4%9A%E4%B8%AA%E6%8C%89%E9%92%AE%E5%8D%95%E5%87%BB%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<p>关于多个按钮单击弹出结果面试题考察分析如下：</p>
<a id="more"></a>
<ul>
<li><p>题目部分代码片段如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btnBox = <span class="built_in">document</span>.getElementById(<span class="string">'btnBox'</span>)</span><br><span class="line"><span class="keyword">var</span> inputs = btnBox.getElementsByTagName(<span class="string">'input'</span>)</span><br><span class="line"><span class="keyword">var</span> l = inputs.length</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;l;i++)&#123; <span class="comment">// 点击时候循环已结束， i = 5</span></span><br><span class="line">    inputs[i].click = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>以上题目涉及到如下知识</p>
<ul>
<li><strong>所有的事件绑定都是异步编程</strong>（绑定的时候方法并没有执行），当点击触发的时候，循环早已经结束<ul>
<li>同步：Js中当前任务没有完成，之后的任务不会执行</li>
<li>异步：Js中当前任务没有完成，可以继续执行其他任务</li>
</ul>
</li>
</ul>
</li>
<li><p>三种解决方案如下：</p>
<ol>
<li>自定义属性<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;l;i++)&#123;</span><br><span class="line">    inputs[i].MyIndex = i</span><br><span class="line">    inputs[i].click = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>..MyIndex)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>闭包<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;l;i++)&#123;</span><br><span class="line">    ~(<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">        inputs[i].click = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(<span class="keyword">this</span>..MyIndex)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 另一种写法, 形成多个不销毁的闭包，性能不好</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;l;i++)&#123;</span><br><span class="line">    inputs[i].click = (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>ES6（块级作用域）<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;l;i++)&#123;</span><br><span class="line">    inputs[i].click = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>如何实现数组去重</title>
    <url>/2020/09/05/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</url>
    <content><![CDATA[<p>实现数组去重有多种方式实现，具体可见如下代码：</p>
<a id="more"></a>
<ol>
<li>循环迭代+map<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">~(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pro = <span class="built_in">Array</span>.prototype</span><br><span class="line">    pro.myDistinct = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>.length;i++)&#123;</span><br><span class="line">            <span class="keyword">let</span> item = <span class="keyword">this</span>[i]</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">typeof</span> obj[item] !== <span class="string">'undefined'</span>)&#123; <span class="comment">// 括号中也可写做 obj[item] !== undefined</span></span><br><span class="line">                <span class="keyword">this</span>[i] = <span class="keyword">this</span>[<span class="keyword">this</span>.length<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">this</span>.length--</span><br><span class="line">                i--</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            obj[item] = item</span><br><span class="line">        &#125;</span><br><span class="line">        obj = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></li>
<li>ES6的Array.filter()<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">~(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pro = <span class="built_in">Array</span>.prototype</span><br><span class="line">    pro.myDistinct = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.filter(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.indexOf(item) === index</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></li>
<li>ES6的Set()（高性能）<br>set结构成员的值都是唯一的，可以接受数组作为参数<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">~(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pro = <span class="built_in">Array</span>.prototype</span><br><span class="line">    pro.myDistinct = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> <span class="keyword">set</span> = new Set(this)</span><br><span class="line">        return [...<span class="keyword">set</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>undefined和null</title>
    <url>/2020/09/05/undefined%E5%92%8Cnull/</url>
    <content><![CDATA[<p>undefined和null出现场景总结如下：</p>
<a id="more"></a>
<ul>
<li><strong>undefined</strong><ul>
<li>变量提升：只声明，未定义，其默认值为undefined</li>
<li>严格模式下，没有明确的执行主体，this的值为undefined</li>
<li>对象没有这个属性名，属性值为undefined</li>
<li>对象没有这个属性名，typeof obj[item]值为字符串’undefined’</li>
<li>函数定义形参不传值，默认值为undefined</li>
<li>函数没有返回值（没有return语句或者return;）</li>
<li>…</li>
</ul>
</li>
<li><strong>null</strong><ul>
<li>手动设置变量的值或者对象某一属性的值为null（后面再赋值）</li>
<li>在JS的DOM元素获取中，如果没有获取到指定的元素对象，结果一般为null</li>
<li>Object.prototype._proto_的值为null</li>
<li>正则捕获的时候，如果没有捕获到结果，默认值是null</li>
<li>…</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>this的考查</title>
    <url>/2020/09/04/this%E7%9A%84%E8%80%83%E6%9F%A5/</url>
    <content><![CDATA[<p>关于this的考查部分题目如下：</p>
<a id="more"></a>
<ol>
<li>输出代码结果<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fullName = <span class="string">'language'</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    fullName = <span class="string">'javascript'</span>,</span><br><span class="line">    prop = &#123;</span><br><span class="line">        getFullName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.fullName</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.prop.getFullName()) <span class="comment">// this为obj.prop，故输出undefined</span></span><br><span class="line"><span class="keyword">var</span> test = obj.prop.getFullName</span><br><span class="line"><span class="built_in">console</span>.log(test()) <span class="comment">// this为window，故输出'language'</span></span><br></pre></td></tr></table></figure></li>
<li>输出代码结果<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'window'</span></span><br><span class="line"><span class="keyword">var</span> Tom = &#123;</span><br><span class="line">    name: <span class="string">'Tom'</span>,</span><br><span class="line">    show: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;,</span><br><span class="line">    wait: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> fun = <span class="keyword">this</span>.show</span><br><span class="line">        fun()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Tom.wait() <span class="comment">// this: Tom =&gt; fun = Tom.show =&gt;fun() =&gt; this: window =&gt; 输出window.name =&gt; 'window'</span></span><br></pre></td></tr></table></figure></li>
<li>输出代码结果<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = <span class="number">0</span></span><br><span class="line">    <span class="keyword">this</span>.b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fun.prototype = &#123; <span class="comment">// 此时fun的constructor改变，指向了Object</span></span><br><span class="line">    b: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = <span class="number">20</span></span><br><span class="line">        alert(<span class="keyword">this</span>.a)</span><br><span class="line">    &#125;,</span><br><span class="line">    c: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = <span class="number">30</span></span><br><span class="line">        alert(<span class="keyword">this</span>.a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> my_fun = <span class="keyword">new</span> fun()</span><br><span class="line">my_fun.b() <span class="comment">// 私有的方法b  this: my_fun =&gt; my_fun.a =&gt; '0'</span></span><br><span class="line">my_fun.c() <span class="comment">// 公有的方法c  this: my_fun =&gt; my_fun.c =&gt; '30'(把当前示例私有属性由0改为了30)</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>原型和原型链</title>
    <url>/2020/09/04/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<p>关于原型和原型链的考查部分题目如下：</p>
<a id="more"></a>
<ul>
<li>输出代码结果<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">100</span></span><br><span class="line">    <span class="keyword">this</span>.y = <span class="number">200</span></span><br><span class="line">    <span class="keyword">this</span>.getX = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Fn.prototype = &#123; <span class="comment">// 批量扩展原型会改变Fn的constructor指向</span></span><br><span class="line">    y: <span class="number">400</span>,</span><br><span class="line">    getX = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.x)</span><br><span class="line">    &#125;,</span><br><span class="line">    getY = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.y)</span><br><span class="line">    &#125;,</span><br><span class="line">    sum = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.x + <span class="keyword">this</span>.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> Fn</span><br><span class="line"><span class="keyword">var</span> f2 = <span class="keyword">new</span> Fn</span><br><span class="line"><span class="built_in">console</span>.log(f1.getX === f2.getX) <span class="comment">// 均为私有 false</span></span><br><span class="line"><span class="built_in">console</span>.log(f1.getY === f2.getY) <span class="comment">// 公有getY true </span></span><br><span class="line"><span class="built_in">console</span>.log(f1.__proto__.getY === Fn.prototype.getY) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(f1.__proto__.getX === f2.getX) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(f1.getX === Fn.prototype.getX) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(f1.constructor) <span class="comment">// Object</span></span><br><span class="line"><span class="built_in">console</span>.log(Fn.prototype.__proto__.constructor) <span class="comment">// Object</span></span><br><span class="line">f1.getX() <span class="comment">// this: f1, f1.x =&gt; 100 </span></span><br><span class="line">f1.__proto__.getX() <span class="comment">// this: f1.__proto(Fn.prototype) =&gt; Fn.prototype.x =&gt; undefined</span></span><br><span class="line">Fn.prototype.getY() <span class="comment">// this: Fn.prototype =&gt; Fn.prototype.y = 400</span></span><br><span class="line">f1.sum() <span class="comment">// this: f1 =&gt; f1.x+f1.y = 100 + 200 = 300</span></span><br><span class="line">Fn.prototype.sum() <span class="comment">// this: Fn.prototype =&gt; undefined + 400 = Nan</span></span><br></pre></td></tr></table></figure>
根据题意，可画原型图如下所示：<br><img src="https://cdn.jsdelivr.net/gh/yc2hang/cdn-assets/photos/prototype.png" alt="avatar"></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>跨域常用解决方案</title>
    <url>/2020/09/06/%E8%B7%A8%E5%9F%9F%E5%B8%B8%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>在前端领域中，跨域是指浏览器允许向服务器发送跨域请求，从而克服Ajax只能同源使用的限制。</p>
<a id="more"></a>
<h3 id="什么是同源策略？"><a href="#什么是同源策略？" class="headerlink" title="什么是同源策略？"></a>什么是同源策略？</h3><div class="note "><p>同源策略是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p></div>
<h5 id="同源策略限制以下几种行为："><a href="#同源策略限制以下几种行为：" class="headerlink" title="同源策略限制以下几种行为："></a>同源策略限制以下几种行为：</h5><ul>
<li>Cookie、LocalStorage 和 IndexDB 无法读取</li>
<li>DOM和JS对象无法获得</li>
<li>AJAX 请求不能发送</li>
</ul>
<h3 id="常见跨域解决方案"><a href="#常见跨域解决方案" class="headerlink" title="常见跨域解决方案"></a>常见跨域解决方案</h3><h4 id="1-JSONP跨域"><a href="#1-JSONP跨域" class="headerlink" title="1. JSONP跨域"></a>1. JSONP跨域</h4><p>jsonp的原理就是利用script标签没有跨域限制，通过script标签src属性，发送带有callback参数的GET请求，服务端将接口返回数据拼凑到callback函数中，返回给浏览器，浏览器解析执行，从而前端拿到callback函数返回的数据。</p>
<ul>
<li>原生JS实现<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span></span><br><span class="line"><span class="actionscript">    script.type = <span class="string">'text/javascript'</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数</span></span></span><br><span class="line"><span class="actionscript">    script.src = <span class="string">'http://www.domain2.com:8080/login?user=admin&amp;callback=handleCallback'</span>;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.head.appendChild(script);</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 回调执行函数</span></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">handleCallback</span><span class="params">(res)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="built_in">JSON</span>.stringify(res));</span></span><br><span class="line">    &#125;</span><br><span class="line"> <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
服务端返回如下（返回时即执行全局函数）：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">handleCallback(&#123;<span class="string">"success"</span>: <span class="literal">true</span>, <span class="string">"user"</span>: <span class="string">"admin"</span>&#125;)</span><br></pre></td></tr></table></figure></li>
<li>后端node实现<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> server = http.createServer();</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> params = querystring.parse(req.url.split(<span class="string">'?'</span>)[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">var</span> fn = params.callback;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// jsonp返回设置</span></span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123; <span class="string">'Content-Type'</span>: <span class="string">'text/javascript'</span> &#125;);</span><br><span class="line">    res.write(fn + <span class="string">'('</span> + <span class="built_in">JSON</span>.stringify(params) + <span class="string">')'</span>);</span><br><span class="line"></span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="string">'8080'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Server is running at port 8080...'</span>);</span><br></pre></td></tr></table></figure>
<div class="note "><p>jsonp的缺点：只能发送get一种请求。 </p></div>

</li>
</ul>
<h4 id="2-跨域资源共享-CORS"><a href="#2-跨域资源共享-CORS" class="headerlink" title="2. 跨域资源共享(CORS)"></a>2. 跨域资源共享(CORS)</h4><div class="note "><p>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。<br>它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。<br>CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。</p></div>
<p>浏览器将CORS跨域请求分为简单请求和非简单请求。只要同时满足一下两个条件，就属于简单请求</p>
<ol>
<li>使用下列方法之一<ul>
<li>head</li>
<li>get</li>
<li>post</li>
</ul>
</li>
<li>请求的Heder是<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Content-Type: 只限于三个值：application/x-www-form-urlencoded、multipart/form-data、text/plain</li>
</ul>
</li>
</ol>
<p>不同时满足上面的两个条件，就属于非简单请求。浏览器对这两种的处理，是不一样的。</p>
<h5 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h5><p>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;cors HTTP&#x2F;1.1</span><br><span class="line">Origin: http:&#x2F;&#x2F;api.bob.com</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0...</span><br></pre></td></tr></table></figure>
<p>上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。<br><strong>CORS请求设置的响应头字段，都以 Access-Control-开头:</strong></p>
<ul>
<li><strong>Access-Control-Allow-Origin</strong>：必选</li>
<li><strong>Access-Control-Allow-Credentials</strong>：可选</li>
<li><strong>Access-Control-Expose-Headers</strong>：可选</li>
</ul>
<h5 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h5><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。<br><strong>预检请求</strong><br>预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。请求头信息里面，关键字段是Origin，表示请求来自哪个源。除了Origin字段，”预检”请求的头信息包括两个特殊字段。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OPTIONS &#x2F;cors HTTP&#x2F;1.1</span><br><span class="line">Origin: http:&#x2F;&#x2F;api.bob.com</span><br><span class="line">Access-Control-Request-Method: PUT</span><br><span class="line">Access-Control-Request-Headers: X-Custom-Header</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0..</span><br></pre></td></tr></table></figure>
<ul>
<li>原生JS实现<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest(); <span class="comment">// IE8/9需用window.XDomainRequest兼容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 前端设置是否带cookie</span></span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">xhr.open(<span class="string">'post'</span>, <span class="string">'http://www.domain2.com:8080/login'</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/x-www-form-urlencoded'</span>);</span><br><span class="line">xhr.send(<span class="string">'user=admin'</span>);</span><br><span class="line"></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">        alert(xhr.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>后端node代码<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> server = http.createServer();</span><br><span class="line"><span class="keyword">var</span> qs = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> postData = <span class="string">''</span>;</span><br><span class="line">    <span class="comment">// 数据块接收中</span></span><br><span class="line">    req.addListener(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">        postData += chunk;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 数据接收完毕</span></span><br><span class="line">    req.addListener(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        postData = qs.parse(postData);</span><br><span class="line">        <span class="comment">// 跨域后台设置</span></span><br><span class="line">        res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">            <span class="string">'Access-Control-Allow-Credentials'</span>: <span class="string">'true'</span>,     <span class="comment">// 后端允许发送Cookie</span></span><br><span class="line">            <span class="string">'Access-Control-Allow-Origin'</span>: <span class="string">'http://www.domain1.com'</span>,    <span class="comment">// 允许访问的域（协议+域名+端口）</span></span><br><span class="line">            <span class="comment">/* </span></span><br><span class="line"><span class="comment">             * 此处设置的cookie还是domain2的而非domain1，因为后端也不能跨域写cookie(nginx反向代理可以实现)，</span></span><br><span class="line"><span class="comment">             * 但只要domain2中写入一次cookie认证，后面的跨域接口都能从domain2中获取cookie，从而实现所有的接口都能跨域访问</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="string">'Set-Cookie'</span>: <span class="string">'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly'</span>  <span class="comment">// HttpOnly的作用是让js无法读取cookie</span></span><br><span class="line">        &#125;);</span><br><span class="line">        res.write(<span class="built_in">JSON</span>.stringify(postData));</span><br><span class="line">        res.end();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="string">'8080'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Server is running at port 8080...'</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="3-nginx代理跨域"><a href="#3-nginx代理跨域" class="headerlink" title="3. nginx代理跨域"></a>3. nginx代理跨域</h4><p>nginx代理跨域，实质和CORS跨域原理一样，通过配置文件设置请求响应头Access-Control-Allow-Origin…等字段。</p>
<ol>
<li>nginx配置解决iconfont跨域<br>浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F; &#123;</span><br><span class="line">  add_header Access-Control-Allow-Origin *;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>nginx反向代理接口跨域<div class="note "><p>跨域问题：同源策略仅是针对浏览器的安全策略。服务器端调用HTTP接口只是使用HTTP协议，不需要同源策略，也就不存在跨域问题。</p></div>

</li>
</ol>
<h4 id="4-nodejs中间件代理跨域"><a href="#4-nodejs中间件代理跨域" class="headerlink" title="4. nodejs中间件代理跨域"></a>4. nodejs中间件代理跨域</h4><p>node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。<br><strong>vue框架的跨域</strong><br>node + vue + webpack + webpack-dev-server搭建的项目，跨域请求接口，直接修改webpack.config.js配置。开发环境下，vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域。<br>webpack.config.js部分配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;&#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;&#125;,</span><br><span class="line">    ...</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        historyApiFallback: <span class="literal">true</span>,</span><br><span class="line">        proxy: [&#123;</span><br><span class="line">            context: <span class="string">'/login'</span>,</span><br><span class="line">            target: <span class="string">'http://www.domain2.com:8080'</span>,  <span class="comment">// 代理跨域目标接口</span></span><br><span class="line">            changeOrigin: <span class="literal">true</span>,</span><br><span class="line">            secure: <span class="literal">false</span>,  <span class="comment">// 当代理某些https服务报错时用</span></span><br><span class="line">            cookieDomainRewrite: <span class="string">'www.domain1.com'</span>  <span class="comment">// 可以为false，表示不修改</span></span><br><span class="line">        &#125;],</span><br><span class="line">        noInfo: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>声明：以上内容转自<a href="https://segmentfault.com/a/1190000011145364" target="_blank" rel="noopener">https://segmentfault.com/a/1190000011145364</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>JS连等运算</title>
    <url>/2020/09/06/JS%E8%BF%9E%E7%AD%89%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p>js连等运算知识点考查</p>
<a id="more"></a>
<ul>
<li><p>输出以下代码的结果并解释为什么</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">n</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">var</span> b = a</span><br><span class="line">a.x = a = &#123; <span class="attr">n</span>: <span class="number">2</span> &#125; <span class="comment">// a = &#123; n: 2 &#125; =&gt; &#123; n: 2 &#125;.x = a</span></span><br><span class="line"><span class="built_in">console</span>.log(a.x) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(b.x) <span class="comment">// &#123; n: 2 &#125;</span></span><br></pre></td></tr></table></figure>
<p>解释：这里的重点是a.x到底是谁<br>简单来说，在赋值过程开始时，a其实是{n:1}<br>a.x=a={n:2}<br>其实在计算机眼中是长成这样的：<br>{n:1}.x=a={n:2}<br>所以，这个赋值发生了两件事<br>//1.把”a”变成了{n:2}<br>//2.把{n:1}的x变成了{n:2}——————–<br>也就是说：<br>a.x = a = {n: 2};<br>其实被计算机执行成了<br>{n:1}.x={n: 2};<br>a={n: 2};<br>所以最后的结果变成了<br>a=={n: 2};<br>console.log(a.x) =&gt; undefined    //因为a没有x属性<br>b=={n: 1, x: {n: 2}}<br>console.log(b.x) =&gt; {n: 2}</p>
</li>
<li><p>连等开始之前，程序会把所有引用都保存起来</p>
</li>
<li><p>连等的过程中，这些值是不变的</p>
</li>
<li><p>等到整个连等结束了，再一起变</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
</search>
