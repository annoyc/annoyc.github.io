{"meta":{"title":"Yc-Sky's Blog","subtitle":"","description":"blog 博客","author":"yczhang","url":"http://yc-sky.top","root":"/"},"pages":[{"title":"","date":"2020-08-22T02:38:03.388Z","updated":"2020-08-22T02:38:03.388Z","comments":true,"path":"404.html","permalink":"http://yc-sky.top/404.html","excerpt":"","text":""},{"title":"categories","date":"2020-08-22T02:52:09.000Z","updated":"2020-08-22T02:52:46.060Z","comments":true,"path":"categories/index.html","permalink":"http://yc-sky.top/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-08-22T02:48:30.000Z","updated":"2020-08-22T02:50:49.800Z","comments":true,"path":"tags/index.html","permalink":"http://yc-sky.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"面试题(undefined和null)","slug":"面试题-undefined和null","date":"2020-09-04T18:49:41.000Z","updated":"2020-09-04T19:01:43.679Z","comments":true,"path":"2020/09/05/面试题-undefined和null/","link":"","permalink":"http://yc-sky.top/2020/09/05/%E9%9D%A2%E8%AF%95%E9%A2%98-undefined%E5%92%8Cnull/","excerpt":"undefined和null出现场景总结如下：","text":"undefined和null出现场景总结如下： undefined 变量提升：只声明，未定义，其默认值为undefined 严格模式下，没有明确的执行主体，this的值为undefined 对象没有这个属性名，属性值为undefined 对象没有这个属性名，typeof obj[item]值为字符串’undefined’ 函数定义形参不传值，默认值为undefined 函数没有返回值（没有return语句或者return;） … null 手动设置变量的值或者对象某一属性的值为null（后面再赋值） 在JS的DOM元素获取中，如果没有获取到指定的元素对象，结果一般为null Object.prototype.proto的值为null 正则捕获的时候，如果没有捕获到结果，默认值是null …","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yc-sky.top/categories/JavaScript/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://yc-sky.top/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"面试题(如何实现数组去重)","slug":"面试题-如何实现数组去重","date":"2020-09-04T18:12:58.000Z","updated":"2020-09-04T18:42:49.605Z","comments":true,"path":"2020/09/05/面试题-如何实现数组去重/","link":"","permalink":"http://yc-sky.top/2020/09/05/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/","excerpt":"实现数组去重有多种方式实现，具体可见如下代码：","text":"实现数组去重有多种方式实现，具体可见如下代码： 循环迭代+map123456789101112131415161718~(function()&#123; let pro = Array.prototype pro.myDistinct = function()&#123; let obj = &#123;&#125; for(let i=0;i&lt;this.length;i++)&#123; let item = this[i] if(typeof obj[item] !== 'undefined')&#123; // 括号中也可写做 obj[item] !== undefined this[i] = this[this.length-1] this.length-- i-- continue &#125; obj[item] = item &#125; obj = null return this &#125;&#125;)() ES6的Array.filter()12345678~(function()&#123; let pro = Array.prototype pro.myDistinct = function()&#123; return this.filter((item, index) =&gt; &#123; return this.indexOf(item) === index &#125;) &#125;&#125;)() ES6的Set()（高性能）set结构成员的值都是唯一的，可以接受数组作为参数1234567~(function()&#123; let pro = Array.prototype pro.myDistinct = function()&#123; var set = new Set(this) return [...set] &#125;&#125;)()","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yc-sky.top/categories/JavaScript/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://yc-sky.top/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"面试题(多个按钮单击事件)","slug":"面试题-多个按钮单击事件","date":"2020-09-04T17:34:01.000Z","updated":"2020-09-04T18:03:15.127Z","comments":true,"path":"2020/09/05/面试题-多个按钮单击事件/","link":"","permalink":"http://yc-sky.top/2020/09/05/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%A4%9A%E4%B8%AA%E6%8C%89%E9%92%AE%E5%8D%95%E5%87%BB%E4%BA%8B%E4%BB%B6/","excerpt":"关于多个按钮单击弹出结果面试题考察分析如下：","text":"关于多个按钮单击弹出结果面试题考察分析如下： 题目部分代码片段如下 12345678var btnBox = document.getElementById('btnBox')var inputs = btnBox.getElementsByTagName('input')var l = inputs.lengthfor(var i=0;i&lt;l;i++)&#123; // 点击时候循环已结束， i = 5 inputs[i].click = function()&#123; alert(i) &#125;&#125; 以上题目涉及到如下知识 所有的事件绑定都是异步编程（绑定的时候方法并没有执行），当点击触发的时候，循环早已经结束 同步：Js中当前任务没有完成，之后的任务不会执行 异步：Js中当前任务没有完成，可以继续执行其他任务 三种解决方案如下： 自定义属性123456for(var i=0;i&lt;l;i++)&#123; inputs[i].MyIndex = i inputs[i].click = function()&#123; alert(this..MyIndex) &#125;&#125; 闭包123456789101112131415for(var i=0;i&lt;l;i++)&#123; ~(function(i)&#123; inputs[i].click = function()&#123; alert(this..MyIndex) &#125; &#125;)(i)&#125;// 另一种写法, 形成多个不销毁的闭包，性能不好for(var i=0;i&lt;l;i++)&#123; inputs[i].click = (function(i)&#123; return function()&#123; alert(i) &#125; &#125;)(i)&#125; ES6（块级作用域）12345for(let i=0;i&lt;l;i++)&#123; inputs[i].click = function()&#123; alert(i) &#125;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yc-sky.top/categories/JavaScript/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://yc-sky.top/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"面试题(原型和原型链)","slug":"面试题-原型和原型链","date":"2020-09-04T14:42:39.000Z","updated":"2020-09-04T17:36:01.032Z","comments":true,"path":"2020/09/04/面试题-原型和原型链/","link":"","permalink":"http://yc-sky.top/2020/09/04/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/","excerpt":"关于原型和原型链的考查部分题目如下：","text":"关于原型和原型链的考查部分题目如下： 输出代码结果123456789101112131415161718192021222324252627282930313233function Fn()&#123; this.x = 100 this.y = 200 this.getX = function()&#123; console.log(this.x) &#125;&#125;Fn.prototype = &#123; // 批量扩展原型会改变Fn的constructor指向 y: 400, getX = function()&#123; console.log(this.x) &#125;, getY = function()&#123; console.log(this.y) &#125;, sum = function()&#123; console.log(this.x + this.y) &#125;&#125;var f1 = new Fnvar f2 = new Fnconsole.log(f1.getX === f2.getX) // 均为私有 falseconsole.log(f1.getY === f2.getY) // 公有getY true console.log(f1.__proto__.getY === Fn.prototype.getY) // trueconsole.log(f1.__proto__.getX === f2.getX) // falseconsole.log(f1.getX === Fn.prototype.getX) // falseconsole.log(f1.constructor) // Objectconsole.log(Fn.prototype.__proto__.constructor) // Objectf1.getX() // this: f1, f1.x =&gt; 100 f1.__proto__.getX() // this: f1.__proto(Fn.prototype) =&gt; Fn.prototype.x =&gt; undefinedFn.prototype.getY() // this: Fn.prototype =&gt; Fn.prototype.y = 400f1.sum() // this: f1 =&gt; f1.x+f1.y = 100 + 200 = 300Fn.prototype.sum() // this: Fn.prototype =&gt; undefined + 400 = Nan 根据题意，可画原型图如下所示：","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yc-sky.top/categories/JavaScript/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://yc-sky.top/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"面试题(闭包的考查)","slug":"面试题-闭包的考查","date":"2020-09-04T12:24:04.000Z","updated":"2020-09-04T19:09:08.949Z","comments":true,"path":"2020/09/04/面试题-闭包的考查/","link":"","permalink":"http://yc-sky.top/2020/09/04/%E9%9D%A2%E8%AF%95%E9%A2%98-%E9%97%AD%E5%8C%85%E7%9A%84%E8%80%83%E6%9F%A5/","excerpt":"关于闭包的考查部分题目如下：","text":"关于闭包的考查部分题目如下： 首先抛出一个问题 你理解的闭包是什么？优缺点有哪些？ 保护： 形成一个私有作用域，保护里面私有变量不受外界干扰 保存： 形成一个不销毁的栈内存，把所需要的变量保存起来以便后续使用 缺点： 形成不销毁的栈内存，比较耗性能 输出代码结果1234567891011121314151617181920console.log(a)var a = 12function fn()&#123; console.log(a) var a = 13 // 若此处去掉var，则答案选A&#125;fn()console.log(a)/** * A、undefined, 12, 13 * B、undefined, undefined, 12 * C、undefined, undefined, 13 * D、有程序报错//** * 答案选B * 1，变量提升 * 2，顺序执行 * 3，执行fn，形成一个私有作用域=》形参赋值，变量提升，顺序执行/ 输出代码结果123456789101112131415var foo = 1function bar()&#123; if(!foo)&#123; // 不管条件是否成立，都要进行变量提示 var foo = 10 &#125; console.log(foo)&#125;bar()/** * 答案选B 变量提升后foo= undefined，条件为true * A、1 * B、10 * C、undefined * D、报错/ 输出代码结果1234567891011121314151617181920212223// =&gt; 全局下的变量提升var n,var c, a=AAAFFFvar n = 0function a()&#123; // 私有作用域，形参赋值：无，变量提升：var n， b=BBBFFF var n = 10 // n=&gt; 11 n=&gt; 12 function b()&#123; // 私有作用域 n++ // n为上级作用域的 console.log(n) &#125; b() // 输出11 return b // return BBBFFF&#125;var c = a() // c为BBBFFF，此时a函数中的私有作用域不销毁c() //再次执行BBBFFF n=&gt;12console.log(n) // 输出全局n， 即 0/** * 选C * A、1 1 1 * B、11 11 0 * C、11 12 0 * D、11 12 12/ 输出代码结果123456789101112// 全局下的变量提升var a, var b, var c, 声明并定义test = AAAFFFvar a = 10, b = 11, c = 12function test(a)&#123; // 私有作用域a=10，var b a = 1 // 私有a由10变为1 var b = 2 // 私有b=2 c = 3 // 全局c由12变为3&#125;test(10)console.log(a) // 全局a = 10console.log(b) // 全局b = 11console.log(c) // 全局c = 3 输出代码结果12345// 首先不管条件是否成立，都要进行变量提升if(!('a' in window))&#123; // 变量提升后window.a = undefined =&gt; 'a' in window 为true var a = 1 // a = 1 未执行&#125;console.log(a) // undefined 输出代码结果12345678910// 全局变量提升 var a, 声明及定义b=BBBFFFvar a = 4function b(x, y, a)&#123; // 执行b形成私有作用域x=1,y=2,a=3 console.log(a) // 私有a=3 arguments[2] = 10 // 非严格模式下，arguments和形参有映射关系 a 变为 10 console.log(a) // 私有a=10&#125;a = b(1, 2, 3) // b函数没有返回值，此时a为undefinedconsole.log(a) // 全局a变为undefined 输出代码结果123456789101112// 全局变量提升 var a, var f, fn = AAAFFFvar a = 9function fn()&#123; a = 0 // 执行fn形成私有作用域，全局a变为0， return BBBFFF return function(b)&#123; return b + a++ &#125;&#125;var f = fn() // 不销毁console.log(f(5)) // 5+a++ =&gt; 5+0++ =&gt; 5 // 此时全局a变为1 BBBFFF111销毁 AAAFFF不销毁console.log(fn()(5)) // fn重新开辟空间并执行，a重置为0=&gt; fn()(5) =&gt; 5+0++ =&gt; 5 // 此时a为1 fn=AAAFFF临时不销毁，等fn()()即BBBFFF222执行完毕后再销毁console.log(f(5)) // 5+a++ =&gt; 5+1++ =&gt; 6 // 此时a为2 BBBFFF222销毁 AAAFFF不销毁 输出代码结果123456789101112// 全局变量提升var ary = AAAFFF111, var res, fn = AAAFFF222var ary = [1, 2, 3, 4]function fn(ary)&#123; // 将ary的地址赋值给形参， 私有ary和全局ary指向同一个内存空间。没有直接关系，但是存在间接关系 ary[0] = 0 // 私有ary = [0, 2, 3, 4] =&gt;全局ary的值也同时被改变 ary = [0] // 私有ary重新开辟空间 ary = [0]，此时的ary与全局ary无任何关联 ary[0] = 100 // 私有ary重新赋值 ary = [100] return ary // 返回私有ary = [100]&#125;var res = fn(ary)console.log(ary) // 全局ary = [0, 2, 3, 4]console.log(res) // ary = [100] 输出代码结果1234567891011function fn(i)&#123; return function(n)&#123; console.log(n+(--i)) &#125;&#125;var f = fn(2) // 不销毁f(3)//4 不销毁 i变为了1fn(4)(5)//8 重新形参赋值，开辟空间fn(6)(7)//12 重新形参赋值，开辟空间f(8)//8 不销毁 i变为了0// 此题与第7题类似 输出代码结果12345678910111213141516// 全局变量提升var num,var obj, var fnvar num = 10var obj = &#123; num: 20 &#125; // 开辟空间obj.fn = (function (num)&#123; // 添加属性fn= this.num = num*3 // this: window =&gt;windwow.num = 60 num++ // =&gt; num = 21 return function(n)&#123; //开辟空间BBBFFF111 this.num += n num++ // 让上级作用域中num++ =&gt; 22 console.log(num) &#125;&#125;)(obj.num)var fn = obj.fn // BBBFFF111 不销毁fn(5) // window.num = window.num+5 =&gt; window.num = 60+5 = 65obj.fn(10) // this: obj =&gt; num+=n =&gt; num = 30 // num++ =&gt; 23console.log(num, obj.num) // 65 30","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yc-sky.top/categories/JavaScript/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://yc-sky.top/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"面试题(this的考查)","slug":"面试题-this的考查","date":"2020-09-04T12:00:27.000Z","updated":"2020-09-04T12:22:40.509Z","comments":true,"path":"2020/09/04/面试题-this的考查/","link":"","permalink":"http://yc-sky.top/2020/09/04/%E9%9D%A2%E8%AF%95%E9%A2%98-this%E7%9A%84%E8%80%83%E6%9F%A5/","excerpt":"关于this的考查部分题目如下：","text":"关于this的考查部分题目如下： 输出代码结果123456789101112var fullName = 'language'var obj = &#123; fullName = 'javascript', prop = &#123; getFullName = function()&#123; return this.fullName &#125; &#125;&#125;console.log(obj.prop.getFullName()) // this为obj.prop，故输出undefinedvar test = obj.prop.getFullNameconsole.log(test()) // this为window，故输出'language' 输出代码结果123456789101112var name = 'window'var Tom = &#123; name: 'Tom', show: function()&#123; console.log(this.name) &#125;, wait: function()&#123; var fun = this.show fun() &#125;&#125;Tom.wait() // this: Tom =&gt; fun = Tom.show =&gt;fun() =&gt; this: window =&gt; 输出window.name =&gt; 'window' 输出代码结果12345678910111213141516171819function fun()&#123; this.a = 0 this.b = function()&#123; alert(this.a) &#125;&#125;fun.prototype = &#123; // 此时fun的constructor改变，指向了Object b: function()&#123; this.a = 20 alert(this.a) &#125;, c: function()&#123; this.a = 30 alert(this.a) &#125;&#125;var my_fun = new fun()my_fun.b() // 私有的方法b this: my_fun =&gt; my_fun.a =&gt; '0'my_fun.c() // 公有的方法c this: my_fun =&gt; my_fun.c =&gt; '30'(把当前示例私有属性由0改为了30)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yc-sky.top/categories/JavaScript/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://yc-sky.top/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"面经(虾皮)","slug":"面经-虾皮","date":"2020-09-04T10:42:32.000Z","updated":"2020-09-04T10:47:54.244Z","comments":true,"path":"2020/09/04/面经-虾皮/","link":"","permalink":"http://yc-sky.top/2020/09/04/%E9%9D%A2%E7%BB%8F-%E8%99%BE%E7%9A%AE/","excerpt":"以下为虾皮一面部分面试题:","text":"以下为虾皮一面部分面试题: 输出以下结果123456789101112131415function Parent()&#123; this.a = 'Parent';&#125;function Tom() &#123; this.a = 'Tom'&#125;Parent.__proto__.print = function()&#123; // Parent.__proto__实际上指向Object.prototype this.a = 4 console.log(this.a)&#125;Parent.print() // 4Tom.print() // 4var child = new Parent()console.log(child.a) // Parentchild.print() // 报错 child.print is not a function f能不能拿到a方法和b方法？12345var F = function()&#123;&#125;;Object.prototype.a = function()&#123;&#125;;Function.prototype.b = function()&#123;&#125;;var f = new F();// f最终指向为Object的prototype，所有只能拿到a方法","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yc-sky.top/categories/JavaScript/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://yc-sky.top/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"面经(yz)","slug":"面经-yz","date":"2020-09-01T09:47:45.000Z","updated":"2020-09-02T08:19:57.161Z","comments":true,"path":"2020/09/01/面经-yz/","link":"","permalink":"http://yc-sky.top/2020/09/01/%E9%9D%A2%E7%BB%8F-yz/","excerpt":"yz某公司部分面试题，学习记录如下","text":"yz某公司部分面试题，学习记录如下 svg是什么？ SVG 意为可缩放矢量图形（Scalable Vector Graphics）。 SVG 使用 XML 格式定义图像。 什么情况下用vuex？ 多个组件间需要传递参数或状态时 较大型项目使用 vue本身的更新机制了解吗？ Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。 简单来说，Vue 在修改数据后，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新。 同步里执行的方法，每个方法里做的事情组成一个事件循环；接下来再次调用的是另一个事件循环。 nextTick：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，会获取更新后的 DOM。 12345678//改变数据vm.message = 'changed'//想要立即使用更新后的DOM。这样不行，因为设置message后DOM还没有更新console.log(vm.$el.textContent) // 并不会得到'changed'//这样可以，nextTick里面的代码会在DOM更新后执行Vue.nextTick(function()&#123; console.log(vm.$el.textContent) //可以得到'changed'&#125;) computed和watch的了解？ computed 本质是一个惰性求值的观察者，具有缓存性，只有当依赖变化后，第一次访问 computed 属性，才会计算新的值，而 watch 则是当数据发生变化便会调用执行函数 从使用场景上说，computed 适用一个数据被多个数据影响，而 watch 适用一个数据影响多个数据; observer和watcher的了解？ Vue 响应系统，其核心有三点：observe、watcher、dep： observe：遍历 data 中的属性，使用 Object.defineProperty 的 get/set 方法对其进行数据劫持； dep：每个属性拥有自己的消息订阅器 dep，用于存放所有订阅了该属性的观察者对象； watcher：观察者（对象），通过 dep 实现对响应属性的监听，监听到结果后，主动触发自己的回调进行响应。123456// 手动注销watchconst unwatch = app.$watch('text', &#123; console.log(val);&#125;, &#123; deep: false&#125;) vue3.0有什么特性？ 此链接内容可供参考 vue中的Object.defineProperty()有什么缺陷？ Object.defineProperty无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应； Object.defineProperty只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍。Proxy可以劫持整个对象，并返回一个新的对象。 Proxy不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性。 var与let、const的区别 var声明变量存在变量提升，let和const不存在变量提升， window可以访问到var声明的值 let、const都是块级局部变量 同一作用域下let和const不能声明同名变量，而var可以 什么是块级作用域？ JS中作用域有：全局作用域、函数作用域。没有块作用域的概念。ECMAScript 6(简称ES6)中新增了块级作用域。块作用域由 {} 包括，if语句和for语句里面的{}也属于块作用域。 js中的class是怎么实现的？ 此链接内容可供参考 js基础类型和引用类型 es5中基础类型包括：number，string，null，undefined，Boolean。es6新增了一种基础类型symbol,基础类型的存储是存放在栈中，原因是基础类型存储的空间很小，存放在栈（stack）中方便查找，且不易于改变 引用类型是指有多个值构成的对象，也就是对象类型比如：Object,Array,Function,Data等，js的引用数据类型是存储在堆中（heap），也就是说存储的变量处的值是一个指针（point），指向存储对象的内存地址。存在堆中的原因是：引用值的大小会改变，所以不能放在栈中，否则会降低变量查询的速度 哪些方法判断值的类型？ 此链接内容可供参考 typeof 运算符 instanceof 通过Object下的toString.call()方法来判断 根据对象的contructor判断 instance of底层实现机制 只要右边变量的 prototype 在左边变量的原型链上即可。因此，instanceof 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 prototype，如果查找失败，则会返回 false 水平居中的几种方式 此链接内容可供参考 BFC(block formatting context) 此链接内容可供参考 使 BFC 内部浮动元素不会到处乱跑 和浮动元素产生边界 如何创建BFC float的值不是none。 position的值不是static或者relative。 display的值是inline-block、table-cell、flex、table-caption或者inline-flex overflow的值不是visible 触发 BFC 只要元素满足下面任一条件即可触发 BFC 特性： body 根元素 浮动元素：float 除 none 以外的值 绝对定位元素：position (absolute、fixed) display 为 inline-block、table-cells、flex overflow 除了 visible 以外的值 (hidden、auto、scroll) 流式布局 此链接内容可供参考 此链接内容可供参考 css的选择器和对应的优先级 此链接内容可供参考 !important &gt; 行内样式&gt;ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性 移动端自适应布局与字体大小自适应 此链接内容可供参考 vw, vh 用js去计算并设置html标签的font-size大小 em和rem的区别 rem 单位翻译为像素值是由 html 元素的字体大小决定的。 此字体大小会被浏览器中字体大小的设置影响，除非显式重写一个具体单位 em 单位转为像素值，取决于他们使用的字体大小。 此字体大小受从父元素继承过来的字体大小，除非显式重写与一个具体单位 数组遍历方法 此链接内容可供参考 post和get Get产生一个TCP数据包；Post产生两个TCP数据包。 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；对于POST，浏览器先发送header，服务器响应100（continue），然后再发送data，服务器响应200（返回数据）； GET幂等，POST不幂等(幂等是指同一个请求方法执行多次和仅执行一次的效果完全相同。) 强制缓存和协商缓存 此链接内容可供参考 http头部字段有哪些？ 此链接内容可供参考","categories":[],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://yc-sky.top/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"为什么需要node作为中间层","slug":"为什么需要node作为中间层","date":"2020-09-01T08:55:09.000Z","updated":"2020-09-01T09:42:45.295Z","comments":true,"path":"2020/09/01/为什么需要node作为中间层/","link":"","permalink":"http://yc-sky.top/2020/09/01/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81node%E4%BD%9C%E4%B8%BA%E4%B8%AD%E9%97%B4%E5%B1%82/","excerpt":"通常我们把Web领域分为客户端和服务端，也就是前端和后端，这里的后端就包含了网关，静态资源，接口，缓存，数据库等。而中间层呢，就是在后端这里再抽离一层出来，在业务上处理和客户端衔接更紧密的部分，比如页面渲染（SSR），数据聚合，接口转发等等。以SSR来说，在服务端将页面渲染好，可以加快用户的首屏加载速度，避免请求时白屏，还有利于网站做SEO，他的好处是比较好理解的。那么对于数据的聚合，接口转发来说，这样做有什么意义呢？","text":"通常我们把Web领域分为客户端和服务端，也就是前端和后端，这里的后端就包含了网关，静态资源，接口，缓存，数据库等。而中间层呢，就是在后端这里再抽离一层出来，在业务上处理和客户端衔接更紧密的部分，比如页面渲染（SSR），数据聚合，接口转发等等。以SSR来说，在服务端将页面渲染好，可以加快用户的首屏加载速度，避免请求时白屏，还有利于网站做SEO，他的好处是比较好理解的。那么对于数据的聚合，接口转发来说，这样做有什么意义呢？ 用Node的原因有以下： 代理：在开发环境下，我们可以利用代理来，解决最常见的跨域问题；在线上环境下，我们可以利用代理，转发请求到多个服务端 缓存：缓存其实是更靠近前端的需求，用户的动作触发数据的更新，node中间层可以直接处理一部分缓存需求。 限流：node中间层，可以针对接口或者路由做响应的限流。 日志：相比其他服务端语言，node中间层的日志记录，能更方便快捷的定位问题（是在浏览器端还是服务端）。 监控：擅长高并发的请求处理，做监控也是合适的选项。 鉴权：有一个中间层去鉴权，也是一种单一职责的实现。 路由：前端更需要掌握页面路由的权限和逻辑。 服务端渲染：node中间层的解决方案更灵活，比如SSR、模板直出、利用一些JS库做预渲染等等。 更多的可能性","categories":[{"name":"前端","slug":"前端","permalink":"http://yc-sky.top/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://yc-sky.top/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yc-sky.top/tags/JavaScript/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-05-07T07:24:10.236Z","updated":"2020-08-22T02:50:31.872Z","comments":true,"path":"2020/05/07/hello-world/","link":"","permalink":"http://yc-sky.top/2020/05/07/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yc-sky.top/tags/Hexo/"}]}],"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yc-sky.top/categories/JavaScript/"},{"name":"前端","slug":"前端","permalink":"http://yc-sky.top/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://yc-sky.top/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yc-sky.top/tags/JavaScript/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yc-sky.top/tags/Hexo/"}]}