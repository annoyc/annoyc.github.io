{"meta":{"title":"Yc的博客","subtitle":"","description":"yc blog 博客","author":"yczhang","url":"http://yc-sky.top","root":"/"},"pages":[{"title":"","date":"2020-08-22T02:38:03.388Z","updated":"2020-08-22T02:38:03.388Z","comments":true,"path":"404.html","permalink":"http://yc-sky.top/404.html","excerpt":"","text":""},{"title":"categories","date":"2020-08-22T02:52:09.000Z","updated":"2020-08-22T02:52:46.060Z","comments":true,"path":"categories/index.html","permalink":"http://yc-sky.top/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-08-22T02:48:30.000Z","updated":"2020-08-22T02:50:49.800Z","comments":true,"path":"tags/index.html","permalink":"http://yc-sky.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JS连等运算","slug":"JS连等运算","date":"2020-09-06T08:29:39.000Z","updated":"2020-09-06T08:47:53.128Z","comments":true,"path":"2020/09/06/JS连等运算/","link":"","permalink":"http://yc-sky.top/2020/09/06/JS%E8%BF%9E%E7%AD%89%E8%BF%90%E7%AE%97/","excerpt":"js连等运算知识点考查","text":"js连等运算知识点考查 输出以下代码的结果并解释为什么 12345var a = &#123; n: 1 &#125;var b = aa.x = a = &#123; n: 2 &#125; // a = &#123; n: 2 &#125; =&gt; &#123; n: 2 &#125;.x = aconsole.log(a.x) // undefinedconsole.log(b.x) // &#123; n: 2 &#125; 解释：这里的重点是a.x到底是谁简单来说，在赋值过程开始时，a其实是{n:1}a.x=a={n:2}其实在计算机眼中是长成这样的：{n:1}.x=a={n:2}所以，这个赋值发生了两件事//1.把”a”变成了{n:2}//2.把{n:1}的x变成了{n:2}——————–也就是说：a.x = a = {n: 2};其实被计算机执行成了{n:1}.x={n: 2};a={n: 2};所以最后的结果变成了a=={n: 2};console.log(a.x) =&gt; undefined //因为a没有x属性b=={n: 1, x: {n: 2}}console.log(b.x) =&gt; {n: 2} 连等开始之前，程序会把所有引用都保存起来 连等的过程中，这些值是不变的 等到整个连等结束了，再一起变","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yc-sky.top/categories/JavaScript/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://yc-sky.top/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"跨域常用解决方案","slug":"跨域常用解决方案","date":"2020-09-06T06:55:05.000Z","updated":"2020-09-06T08:04:47.233Z","comments":true,"path":"2020/09/06/跨域常用解决方案/","link":"","permalink":"http://yc-sky.top/2020/09/06/%E8%B7%A8%E5%9F%9F%E5%B8%B8%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"在前端领域中，跨域是指浏览器允许向服务器发送跨域请求，从而克服Ajax只能同源使用的限制。","text":"在前端领域中，跨域是指浏览器允许向服务器发送跨域请求，从而克服Ajax只能同源使用的限制。 什么是同源策略？同源策略是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。 同源策略限制以下几种行为： Cookie、LocalStorage 和 IndexDB 无法读取 DOM和JS对象无法获得 AJAX 请求不能发送 常见跨域解决方案1. JSONP跨域jsonp的原理就是利用script标签没有跨域限制，通过script标签src属性，发送带有callback参数的GET请求，服务端将接口返回数据拼凑到callback函数中，返回给浏览器，浏览器解析执行，从而前端拿到callback函数返回的数据。 原生JS实现12345678910111213&lt;script&gt; var script = document.createElement('script'); script.type = 'text/javascript'; // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数 script.src = 'http://www.domain2.com:8080/login?user=admin&amp;callback=handleCallback'; document.head.appendChild(script); // 回调执行函数 function handleCallback(res) &#123; alert(JSON.stringify(res)); &#125; &lt;/script&gt; 服务端返回如下（返回时即执行全局函数）：1handleCallback(&#123;\"success\": true, \"user\": \"admin\"&#125;) 后端node实现1234567891011121314151617var querystring = require('querystring');var http = require('http');var server = http.createServer();server.on('request', function(req, res) &#123; var params = querystring.parse(req.url.split('?')[1]); var fn = params.callback; // jsonp返回设置 res.writeHead(200, &#123; 'Content-Type': 'text/javascript' &#125;); res.write(fn + '(' + JSON.stringify(params) + ')'); res.end();&#125;);server.listen('8080');console.log('Server is running at port 8080...'); jsonp的缺点：只能发送get一种请求。 2. 跨域资源共享(CORS)CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。 浏览器将CORS跨域请求分为简单请求和非简单请求。只要同时满足一下两个条件，就属于简单请求 使用下列方法之一 head get post 请求的Heder是 Accept Accept-Language Content-Language Content-Type: 只限于三个值：application/x-www-form-urlencoded、multipart/form-data、text/plain 不同时满足上面的两个条件，就属于非简单请求。浏览器对这两种的处理，是不一样的。 简单请求对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。 123456GET &#x2F;cors HTTP&#x2F;1.1Origin: http:&#x2F;&#x2F;api.bob.comHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla&#x2F;5.0... 上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。CORS请求设置的响应头字段，都以 Access-Control-开头: Access-Control-Allow-Origin：必选 Access-Control-Allow-Credentials：可选 Access-Control-Expose-Headers：可选 非简单请求非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。预检请求预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。请求头信息里面，关键字段是Origin，表示请求来自哪个源。除了Origin字段，”预检”请求的头信息包括两个特殊字段。 12345678OPTIONS &#x2F;cors HTTP&#x2F;1.1Origin: http:&#x2F;&#x2F;api.bob.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla&#x2F;5.0.. 原生JS实现1234567891011121314var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容// 前端设置是否带cookiexhr.withCredentials = true;xhr.open('post', 'http://www.domain2.com:8080/login', true);xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');xhr.send('user=admin');xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; alert(xhr.responseText); &#125;&#125;; 后端node代码1234567891011121314151617181920212223242526272829var http = require('http');var server = http.createServer();var qs = require('querystring');server.on('request', function(req, res) &#123; var postData = ''; // 数据块接收中 req.addListener('data', function(chunk) &#123; postData += chunk; &#125;); // 数据接收完毕 req.addListener('end', function() &#123; postData = qs.parse(postData); // 跨域后台设置 res.writeHead(200, &#123; 'Access-Control-Allow-Credentials': 'true', // 后端允许发送Cookie 'Access-Control-Allow-Origin': 'http://www.domain1.com', // 允许访问的域（协议+域名+端口） /* * 此处设置的cookie还是domain2的而非domain1，因为后端也不能跨域写cookie(nginx反向代理可以实现)， * 但只要domain2中写入一次cookie认证，后面的跨域接口都能从domain2中获取cookie，从而实现所有的接口都能跨域访问 */ 'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly' // HttpOnly的作用是让js无法读取cookie &#125;); res.write(JSON.stringify(postData)); res.end(); &#125;);&#125;);server.listen('8080');console.log('Server is running at port 8080...'); 3. nginx代理跨域nginx代理跨域，实质和CORS跨域原理一样，通过配置文件设置请求响应头Access-Control-Allow-Origin…等字段。 nginx配置解决iconfont跨域浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。123location &#x2F; &#123; add_header Access-Control-Allow-Origin *;&#125; nginx反向代理接口跨域跨域问题：同源策略仅是针对浏览器的安全策略。服务器端调用HTTP接口只是使用HTTP协议，不需要同源策略，也就不存在跨域问题。 4. nodejs中间件代理跨域node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。vue框架的跨域node + vue + webpack + webpack-dev-server搭建的项目，跨域请求接口，直接修改webpack.config.js配置。开发环境下，vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域。webpack.config.js部分配置： 12345678910111213141516module.exports = &#123; entry: &#123;&#125;, module: &#123;&#125;, ... devServer: &#123; historyApiFallback: true, proxy: [&#123; context: '/login', target: 'http://www.domain2.com:8080', // 代理跨域目标接口 changeOrigin: true, secure: false, // 当代理某些https服务报错时用 cookieDomainRewrite: 'www.domain1.com' // 可以为false，表示不修改 &#125;], noInfo: true &#125;&#125; 声明：以上内容转自https://segmentfault.com/a/1190000011145364","categories":[],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://yc-sky.top/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"回流和重绘","slug":"回流和重绘","date":"2020-09-05T15:03:53.000Z","updated":"2020-09-05T15:16:30.112Z","comments":true,"path":"2020/09/05/回流和重绘/","link":"","permalink":"http://yc-sky.top/2020/09/05/%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98/","excerpt":"网页的回流和重绘知识点如下：","text":"网页的回流和重绘知识点如下： 回流回流又称之为重排，当Render Tree中的一部分（或者全部）因元素的规模，尺寸，布局等改变，而需要重新构建页面，就会触发回流具体总结为： 页面初始渲染 添加、删除可见的DOM元素 改变元素位置，尺寸，内容触发回流的属性： 盒子模型相关属性：width、height、display、border、border-width… 定位及浮动：position、left、right、top、bottom、float、padding、margin… 文字相关：text-align、overflow、font-weight、font-family、line-height，vertical-align、font-size、white-space… 重绘当Render Tree中的一些元素需要更新属性，而这些属性只是影响到元素的外观，风格而不影响布局，就会触发重绘回流一定重绘，但是重绘不一定回流触发重绘的属性： color、border-style、border-radius、outline、visibility、background-color、text-decoration、background、background-image、box-shadow… 如何减少回流和重绘 用translate代替top 用opacity代替visibility 预先定义好className，然后统一修改Dom的className 不要把Dom结点的属性值放在一个循环里面变成循环变量 让要操作的元素进行“离线处理”，处理完后一起更新","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yc-sky.top/categories/CSS/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://yc-sky.top/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"undefined和null","slug":"undefined和null","date":"2020-09-04T18:49:41.000Z","updated":"2020-09-05T15:18:00.076Z","comments":true,"path":"2020/09/05/undefined和null/","link":"","permalink":"http://yc-sky.top/2020/09/05/undefined%E5%92%8Cnull/","excerpt":"undefined和null出现场景总结如下：","text":"undefined和null出现场景总结如下： undefined 变量提升：只声明，未定义，其默认值为undefined 严格模式下，没有明确的执行主体，this的值为undefined 对象没有这个属性名，属性值为undefined 对象没有这个属性名，typeof obj[item]值为字符串’undefined’ 函数定义形参不传值，默认值为undefined 函数没有返回值（没有return语句或者return;） … null 手动设置变量的值或者对象某一属性的值为null（后面再赋值） 在JS的DOM元素获取中，如果没有获取到指定的元素对象，结果一般为null Object.prototype._proto_的值为null 正则捕获的时候，如果没有捕获到结果，默认值是null …","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yc-sky.top/categories/JavaScript/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://yc-sky.top/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"如何实现数组去重","slug":"如何实现数组去重","date":"2020-09-04T18:12:58.000Z","updated":"2020-09-05T15:17:43.232Z","comments":true,"path":"2020/09/05/如何实现数组去重/","link":"","permalink":"http://yc-sky.top/2020/09/05/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/","excerpt":"实现数组去重有多种方式实现，具体可见如下代码：","text":"实现数组去重有多种方式实现，具体可见如下代码： 循环迭代+map123456789101112131415161718~(function()&#123; let pro = Array.prototype pro.myDistinct = function()&#123; let obj = &#123;&#125; for(let i=0;i&lt;this.length;i++)&#123; let item = this[i] if(typeof obj[item] !== 'undefined')&#123; // 括号中也可写做 obj[item] !== undefined this[i] = this[this.length-1] this.length-- i-- continue &#125; obj[item] = item &#125; obj = null return this &#125;&#125;)() ES6的Array.filter()12345678~(function()&#123; let pro = Array.prototype pro.myDistinct = function()&#123; return this.filter((item, index) =&gt; &#123; return this.indexOf(item) === index &#125;) &#125;&#125;)() ES6的Set()（高性能）set结构成员的值都是唯一的，可以接受数组作为参数1234567~(function()&#123; let pro = Array.prototype pro.myDistinct = function()&#123; var set = new Set(this) return [...set] &#125;&#125;)()","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yc-sky.top/categories/JavaScript/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://yc-sky.top/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"多个按钮单击事件","slug":"多个按钮单击事件","date":"2020-09-04T17:34:01.000Z","updated":"2020-09-05T15:17:28.450Z","comments":true,"path":"2020/09/05/多个按钮单击事件/","link":"","permalink":"http://yc-sky.top/2020/09/05/%E5%A4%9A%E4%B8%AA%E6%8C%89%E9%92%AE%E5%8D%95%E5%87%BB%E4%BA%8B%E4%BB%B6/","excerpt":"关于多个按钮单击弹出结果面试题考察分析如下：","text":"关于多个按钮单击弹出结果面试题考察分析如下： 题目部分代码片段如下 12345678var btnBox = document.getElementById('btnBox')var inputs = btnBox.getElementsByTagName('input')var l = inputs.lengthfor(var i=0;i&lt;l;i++)&#123; // 点击时候循环已结束， i = 5 inputs[i].click = function()&#123; alert(i) &#125;&#125; 以上题目涉及到如下知识 所有的事件绑定都是异步编程（绑定的时候方法并没有执行），当点击触发的时候，循环早已经结束 同步：Js中当前任务没有完成，之后的任务不会执行 异步：Js中当前任务没有完成，可以继续执行其他任务 三种解决方案如下： 自定义属性123456for(var i=0;i&lt;l;i++)&#123; inputs[i].MyIndex = i inputs[i].click = function()&#123; alert(this..MyIndex) &#125;&#125; 闭包123456789101112131415for(var i=0;i&lt;l;i++)&#123; ~(function(i)&#123; inputs[i].click = function()&#123; alert(this..MyIndex) &#125; &#125;)(i)&#125;// 另一种写法, 形成多个不销毁的闭包，性能不好for(var i=0;i&lt;l;i++)&#123; inputs[i].click = (function(i)&#123; return function()&#123; alert(i) &#125; &#125;)(i)&#125; ES6（块级作用域）12345for(let i=0;i&lt;l;i++)&#123; inputs[i].click = function()&#123; alert(i) &#125;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yc-sky.top/categories/JavaScript/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://yc-sky.top/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"原型和原型链","slug":"原型和原型链","date":"2020-09-04T14:42:39.000Z","updated":"2020-09-05T15:18:28.993Z","comments":true,"path":"2020/09/04/原型和原型链/","link":"","permalink":"http://yc-sky.top/2020/09/04/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/","excerpt":"关于原型和原型链的考查部分题目如下：","text":"关于原型和原型链的考查部分题目如下： 输出代码结果123456789101112131415161718192021222324252627282930313233function Fn()&#123; this.x = 100 this.y = 200 this.getX = function()&#123; console.log(this.x) &#125;&#125;Fn.prototype = &#123; // 批量扩展原型会改变Fn的constructor指向 y: 400, getX = function()&#123; console.log(this.x) &#125;, getY = function()&#123; console.log(this.y) &#125;, sum = function()&#123; console.log(this.x + this.y) &#125;&#125;var f1 = new Fnvar f2 = new Fnconsole.log(f1.getX === f2.getX) // 均为私有 falseconsole.log(f1.getY === f2.getY) // 公有getY true console.log(f1.__proto__.getY === Fn.prototype.getY) // trueconsole.log(f1.__proto__.getX === f2.getX) // falseconsole.log(f1.getX === Fn.prototype.getX) // falseconsole.log(f1.constructor) // Objectconsole.log(Fn.prototype.__proto__.constructor) // Objectf1.getX() // this: f1, f1.x =&gt; 100 f1.__proto__.getX() // this: f1.__proto(Fn.prototype) =&gt; Fn.prototype.x =&gt; undefinedFn.prototype.getY() // this: Fn.prototype =&gt; Fn.prototype.y = 400f1.sum() // this: f1 =&gt; f1.x+f1.y = 100 + 200 = 300Fn.prototype.sum() // this: Fn.prototype =&gt; undefined + 400 = Nan 根据题意，可画原型图如下所示：","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yc-sky.top/categories/JavaScript/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://yc-sky.top/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"闭包的考查","slug":"闭包的考查","date":"2020-09-04T12:24:04.000Z","updated":"2020-09-05T15:17:10.105Z","comments":true,"path":"2020/09/04/闭包的考查/","link":"","permalink":"http://yc-sky.top/2020/09/04/%E9%97%AD%E5%8C%85%E7%9A%84%E8%80%83%E6%9F%A5/","excerpt":"关于闭包的考查部分题目如下：","text":"关于闭包的考查部分题目如下： 首先抛出一个问题 你理解的闭包是什么？优缺点有哪些？ 保护： 形成一个私有作用域，保护里面私有变量不受外界干扰 保存： 形成一个不销毁的栈内存，把所需要的变量保存起来以便后续使用 缺点： 形成不销毁的栈内存，比较耗性能 输出代码结果1234567891011121314151617181920console.log(a)var a = 12function fn()&#123; console.log(a) var a = 13 // 若此处去掉var，则答案选A&#125;fn()console.log(a)/** * A、undefined, 12, 13 * B、undefined, undefined, 12 * C、undefined, undefined, 13 * D、有程序报错//** * 答案选B * 1，变量提升 * 2，顺序执行 * 3，执行fn，形成一个私有作用域=》形参赋值，变量提升，顺序执行/ 输出代码结果123456789101112131415var foo = 1function bar()&#123; if(!foo)&#123; // 不管条件是否成立，都要进行变量提示 var foo = 10 &#125; console.log(foo)&#125;bar()/** * 答案选B 变量提升后foo= undefined，条件为true * A、1 * B、10 * C、undefined * D、报错/ 输出代码结果1234567891011121314151617181920212223// =&gt; 全局下的变量提升var n,var c, a=AAAFFFvar n = 0function a()&#123; // 私有作用域，形参赋值：无，变量提升：var n， b=BBBFFF var n = 10 // n=&gt; 11 n=&gt; 12 function b()&#123; // 私有作用域 n++ // n为上级作用域的 console.log(n) &#125; b() // 输出11 return b // return BBBFFF&#125;var c = a() // c为BBBFFF，此时a函数中的私有作用域不销毁c() //再次执行BBBFFF n=&gt;12console.log(n) // 输出全局n， 即 0/** * 选C * A、1 1 1 * B、11 11 0 * C、11 12 0 * D、11 12 12/ 输出代码结果123456789101112// 全局下的变量提升var a, var b, var c, 声明并定义test = AAAFFFvar a = 10, b = 11, c = 12function test(a)&#123; // 私有作用域a=10，var b a = 1 // 私有a由10变为1 var b = 2 // 私有b=2 c = 3 // 全局c由12变为3&#125;test(10)console.log(a) // 全局a = 10console.log(b) // 全局b = 11console.log(c) // 全局c = 3 输出代码结果12345// 首先不管条件是否成立，都要进行变量提升if(!('a' in window))&#123; // 变量提升后window.a = undefined =&gt; 'a' in window 为true var a = 1 // a = 1 未执行&#125;console.log(a) // undefined 输出代码结果12345678910// 全局变量提升 var a, 声明及定义b=BBBFFFvar a = 4function b(x, y, a)&#123; // 执行b形成私有作用域x=1,y=2,a=3 console.log(a) // 私有a=3 arguments[2] = 10 // 非严格模式下，arguments和形参有映射关系 a 变为 10 console.log(a) // 私有a=10&#125;a = b(1, 2, 3) // b函数没有返回值，此时a为undefinedconsole.log(a) // 全局a变为undefined 输出代码结果123456789101112// 全局变量提升 var a, var f, fn = AAAFFFvar a = 9function fn()&#123; a = 0 // 执行fn形成私有作用域，全局a变为0， return BBBFFF return function(b)&#123; return b + a++ &#125;&#125;var f = fn() // 不销毁console.log(f(5)) // 5+a++ =&gt; 5+0++ =&gt; 5 // 此时全局a变为1 BBBFFF111销毁 AAAFFF不销毁console.log(fn()(5)) // fn重新开辟空间并执行，a重置为0=&gt; fn()(5) =&gt; 5+0++ =&gt; 5 // 此时a为1 fn=AAAFFF临时不销毁，等fn()()即BBBFFF222执行完毕后再销毁console.log(f(5)) // 5+a++ =&gt; 5+1++ =&gt; 6 // 此时a为2 BBBFFF222销毁 AAAFFF不销毁 输出代码结果123456789101112// 全局变量提升var ary = AAAFFF111, var res, fn = AAAFFF222var ary = [1, 2, 3, 4]function fn(ary)&#123; // 将ary的地址赋值给形参， 私有ary和全局ary指向同一个内存空间。没有直接关系，但是存在间接关系 ary[0] = 0 // 私有ary = [0, 2, 3, 4] =&gt;全局ary的值也同时被改变 ary = [0] // 私有ary重新开辟空间 ary = [0]，此时的ary与全局ary无任何关联 ary[0] = 100 // 私有ary重新赋值 ary = [100] return ary // 返回私有ary = [100]&#125;var res = fn(ary)console.log(ary) // 全局ary = [0, 2, 3, 4]console.log(res) // ary = [100] 输出代码结果1234567891011function fn(i)&#123; return function(n)&#123; console.log(n+(--i)) &#125;&#125;var f = fn(2) // 不销毁f(3)//4 不销毁 i变为了1fn(4)(5)//8 重新形参赋值，开辟空间fn(6)(7)//12 重新形参赋值，开辟空间f(8)//8 不销毁 i变为了0// 此题与第7题类似 输出代码结果12345678910111213141516// 全局变量提升var num,var obj, var fnvar num = 10var obj = &#123; num: 20 &#125; // 开辟空间obj.fn = (function (num)&#123; // 添加属性fn= this.num = num*3 // this: window =&gt;windwow.num = 60 num++ // =&gt; num = 21 return function(n)&#123; //开辟空间BBBFFF111 this.num += n num++ // 让上级作用域中num++ =&gt; 22 console.log(num) &#125;&#125;)(obj.num)var fn = obj.fn // BBBFFF111 不销毁fn(5) // window.num = window.num+5 =&gt; window.num = 60+5 = 65obj.fn(10) // this: obj =&gt; num+=n =&gt; num = 30 // num++ =&gt; 23console.log(num, obj.num) // 65 30","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yc-sky.top/categories/JavaScript/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://yc-sky.top/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"this的考查","slug":"this的考查","date":"2020-09-04T12:00:27.000Z","updated":"2020-09-05T15:18:15.456Z","comments":true,"path":"2020/09/04/this的考查/","link":"","permalink":"http://yc-sky.top/2020/09/04/this%E7%9A%84%E8%80%83%E6%9F%A5/","excerpt":"关于this的考查部分题目如下：","text":"关于this的考查部分题目如下： 输出代码结果123456789101112var fullName = 'language'var obj = &#123; fullName = 'javascript', prop = &#123; getFullName = function()&#123; return this.fullName &#125; &#125;&#125;console.log(obj.prop.getFullName()) // this为obj.prop，故输出undefinedvar test = obj.prop.getFullNameconsole.log(test()) // this为window，故输出'language' 输出代码结果123456789101112var name = 'window'var Tom = &#123; name: 'Tom', show: function()&#123; console.log(this.name) &#125;, wait: function()&#123; var fun = this.show fun() &#125;&#125;Tom.wait() // this: Tom =&gt; fun = Tom.show =&gt;fun() =&gt; this: window =&gt; 输出window.name =&gt; 'window' 输出代码结果12345678910111213141516171819function fun()&#123; this.a = 0 this.b = function()&#123; alert(this.a) &#125;&#125;fun.prototype = &#123; // 此时fun的constructor改变，指向了Object b: function()&#123; this.a = 20 alert(this.a) &#125;, c: function()&#123; this.a = 30 alert(this.a) &#125;&#125;var my_fun = new fun()my_fun.b() // 私有的方法b this: my_fun =&gt; my_fun.a =&gt; '0'my_fun.c() // 公有的方法c this: my_fun =&gt; my_fun.c =&gt; '30'(把当前示例私有属性由0改为了30)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yc-sky.top/categories/JavaScript/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://yc-sky.top/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"面经(虾皮)","slug":"面经-虾皮","date":"2020-09-04T10:42:32.000Z","updated":"2020-09-04T10:47:54.244Z","comments":true,"path":"2020/09/04/面经-虾皮/","link":"","permalink":"http://yc-sky.top/2020/09/04/%E9%9D%A2%E7%BB%8F-%E8%99%BE%E7%9A%AE/","excerpt":"以下为虾皮一面部分面试题:","text":"以下为虾皮一面部分面试题: 输出以下结果123456789101112131415function Parent()&#123; this.a = 'Parent';&#125;function Tom() &#123; this.a = 'Tom'&#125;Parent.__proto__.print = function()&#123; // Parent.__proto__实际上指向Object.prototype this.a = 4 console.log(this.a)&#125;Parent.print() // 4Tom.print() // 4var child = new Parent()console.log(child.a) // Parentchild.print() // 报错 child.print is not a function f能不能拿到a方法和b方法？12345var F = function()&#123;&#125;;Object.prototype.a = function()&#123;&#125;;Function.prototype.b = function()&#123;&#125;;var f = new F();// f最终指向为Object的prototype，所有只能拿到a方法","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yc-sky.top/categories/JavaScript/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://yc-sky.top/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"面经(yz)","slug":"面经-yz","date":"2020-09-01T09:47:45.000Z","updated":"2020-09-06T09:50:09.542Z","comments":true,"path":"2020/09/01/面经-yz/","link":"","permalink":"http://yc-sky.top/2020/09/01/%E9%9D%A2%E7%BB%8F-yz/","excerpt":"yz某公司部分面试题，学习记录如下","text":"yz某公司部分面试题，学习记录如下 svg是什么？ SVG 意为可缩放矢量图形（Scalable Vector Graphics）。 SVG 使用 XML 格式定义图像。 什么情况下用vuex？ 多个组件间需要传递参数或状态时 较大型项目使用 vue本身的更新机制了解吗？ Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。 简单来说，Vue 在修改数据后，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新。 同步里执行的方法，每个方法里做的事情组成一个事件循环；接下来再次调用的是另一个事件循环。 nextTick：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，会获取更新后的 DOM。 12345678//改变数据vm.message = 'changed'//想要立即使用更新后的DOM。这样不行，因为设置message后DOM还没有更新console.log(vm.$el.textContent) // 并不会得到'changed'//这样可以，nextTick里面的代码会在DOM更新后执行Vue.nextTick(function()&#123; console.log(vm.$el.textContent) //可以得到'changed'&#125;) computed和watch的了解？ computed 本质是一个惰性求值的观察者，具有缓存性，只有当依赖变化后，第一次访问 computed 属性，才会计算新的值，而 watch 则是当数据发生变化便会调用执行函数 从使用场景上说，computed 适用一个数据被多个数据影响，而 watch 适用一个数据影响多个数据; observer和watcher的了解？ Vue 响应系统，其核心有三点：observe、watcher、dep： observe：遍历 data 中的属性，使用 Object.defineProperty 的 get/set 方法对其进行数据劫持； dep：每个属性拥有自己的消息订阅器 dep，用于存放所有订阅了该属性的观察者对象； watcher：观察者（对象），通过 dep 实现对响应属性的监听，监听到结果后，主动触发自己的回调进行响应。123456// 手动注销watchconst unwatch = app.$watch('text', &#123; console.log(val);&#125;, &#123; deep: false&#125;) vue3.0有什么特性？ 此链接内容可供参考 vue中的Object.defineProperty()有什么缺陷？ Object.defineProperty无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应； Object.defineProperty只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍。Proxy可以劫持整个对象，并返回一个新的对象。 Proxy不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性。 var与let、const的区别 var声明变量存在变量提升，let和const不存在变量提升， window可以访问到var声明的值 let、const都是块级局部变量 同一作用域下let和const不能声明同名变量，而var可以 什么是块级作用域？ JS中作用域有：全局作用域、函数作用域。没有块作用域的概念。ECMAScript 6(简称ES6)中新增了块级作用域。块作用域由 {} 包括，if语句和for语句里面的{}也属于块作用域。 js中的class是怎么实现的？ 此链接内容可供参考 js基础类型和引用类型 es5中基础类型包括：number，string，null，undefined，Boolean。es6新增了一种基础类型symbol,基础类型的存储是存放在栈中，原因是基础类型存储的空间很小，存放在栈（stack）中方便查找，且不易于改变 引用类型是指有多个值构成的对象，也就是对象类型比如：Object,Array,Function,Data等，js的引用数据类型是存储在堆中（heap），也就是说存储的变量处的值是一个指针（point），指向存储对象的内存地址。存在堆中的原因是：引用值的大小会改变，所以不能放在栈中，否则会降低变量查询的速度 哪些方法判断值的类型？ 此链接内容可供参考 typeof 运算符 instanceof 通过Object下的toString.call()方法来判断 根据对象的contructor判断 instance of底层实现机制 只要右边变量的 prototype 在左边变量的原型链上即可。因此，instanceof 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 prototype，如果查找失败，则会返回 false 水平居中的几种方式 此链接内容可供参考 BFC(block formatting context) 此链接内容可供参考 使 BFC 内部浮动元素不会到处乱跑 和浮动元素产生边界 如何创建BFC float的值不是none。 position的值不是static或者relative。 display的值是inline-block、table-cell、flex、table-caption或者inline-flex overflow的值不是visible 触发 BFC 只要元素满足下面任一条件即可触发 BFC 特性： body 根元素 浮动元素：float 除 none 以外的值 绝对定位元素：position (absolute、fixed) display 为 inline-block、table-cells、flex overflow 除了 visible 以外的值 (hidden、auto、scroll) 流式布局 此链接内容可供参考 此链接内容可供参考 css的选择器和对应的优先级 此链接内容可供参考 !important &gt; 行内样式&gt;ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性 移动端自适应布局与字体大小自适应 此链接内容可供参考 vw, vh 用js去计算并设置html标签的font-size大小 em和rem的区别 rem 单位翻译为像素值是由 html 元素的字体大小决定的。 此字体大小会被浏览器中字体大小的设置影响，除非显式重写一个具体单位 em 单位转为像素值，取决于他们使用的字体大小。 此字体大小受从父元素继承过来的字体大小，除非显式重写与一个具体单位 数组遍历方法 此链接内容可供参考 post和get Get产生一个TCP数据包；Post产生两个TCP数据包。 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；对于POST，浏览器先发送header，服务器响应100（continue），然后再发送data，服务器响应200（返回数据）； GET幂等，POST不幂等(幂等是指同一个请求方法执行多次和仅执行一次的效果完全相同。) 强制缓存和协商缓存 此链接内容可供参考 http头部字段有哪些？ 此链接内容可供参考 首页一个sleep函数（可从Promise，Generator，async/await等角度实现）12345678910function sleep(ms)&#123; return new Promise(resolve=&gt;&#123; setTimeout(resolve, ms) &#125;)&#125;~(async ()=&gt;&#123; console.log(111) await sleep(2000) console.log(222)&#125;)()","categories":[],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://yc-sky.top/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"为什么需要node作为中间层","slug":"为什么需要node作为中间层","date":"2020-09-01T08:55:09.000Z","updated":"2020-09-05T15:05:00.285Z","comments":true,"path":"2020/09/01/为什么需要node作为中间层/","link":"","permalink":"http://yc-sky.top/2020/09/01/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81node%E4%BD%9C%E4%B8%BA%E4%B8%AD%E9%97%B4%E5%B1%82/","excerpt":"通常我们把Web领域分为客户端和服务端，也就是前端和后端，这里的后端就包含了网关，静态资源，接口，缓存，数据库等。而中间层呢，就是在后端这里再抽离一层出来，在业务上处理和客户端衔接更紧密的部分，比如页面渲染（SSR），数据聚合，接口转发等等。以SSR来说，在服务端将页面渲染好，可以加快用户的首屏加载速度，避免请求时白屏，还有利于网站做SEO，他的好处是比较好理解的。那么对于数据的聚合，接口转发来说，这样做有什么意义呢？","text":"通常我们把Web领域分为客户端和服务端，也就是前端和后端，这里的后端就包含了网关，静态资源，接口，缓存，数据库等。而中间层呢，就是在后端这里再抽离一层出来，在业务上处理和客户端衔接更紧密的部分，比如页面渲染（SSR），数据聚合，接口转发等等。以SSR来说，在服务端将页面渲染好，可以加快用户的首屏加载速度，避免请求时白屏，还有利于网站做SEO，他的好处是比较好理解的。那么对于数据的聚合，接口转发来说，这样做有什么意义呢？ 用Node的原因有以下： 代理：在开发环境下，我们可以利用代理来，解决最常见的跨域问题；在线上环境下，我们可以利用代理，转发请求到多个服务端 缓存：缓存其实是更靠近前端的需求，用户的动作触发数据的更新，node中间层可以直接处理一部分缓存需求。 限流：node中间层，可以针对接口或者路由做响应的限流。 日志：相比其他服务端语言，node中间层的日志记录，能更方便快捷的定位问题（是在浏览器端还是服务端）。 监控：擅长高并发的请求处理，做监控也是合适的选项。 鉴权：有一个中间层去鉴权，也是一种单一职责的实现。 路由：前端更需要掌握页面路由的权限和逻辑。 服务端渲染：node中间层的解决方案更灵活，比如SSR、模板直出、利用一些JS库做预渲染等等。 更多的可能性","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yc-sky.top/categories/JavaScript/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://yc-sky.top/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-05-07T07:24:10.236Z","updated":"2020-08-22T02:50:31.872Z","comments":true,"path":"2020/05/07/hello-world/","link":"","permalink":"http://yc-sky.top/2020/05/07/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yc-sky.top/tags/Hexo/"}]}],"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yc-sky.top/categories/JavaScript/"},{"name":"CSS","slug":"CSS","permalink":"http://yc-sky.top/categories/CSS/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://yc-sky.top/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yc-sky.top/tags/Hexo/"}]}