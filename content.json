{"meta":{"title":"Yc-Sky's Blog","subtitle":"","description":"blog 博客","author":"yczhang","url":"http://yc-sky.top","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-05-08T03:29:51.446Z","updated":"2020-05-08T03:29:51.446Z","comments":true,"path":"404.html","permalink":"http://yc-sky.top/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"所有分类","date":"2020-05-08T03:22:35.774Z","updated":"2020-05-08T03:22:35.774Z","comments":true,"path":"categories/index.html","permalink":"http://yc-sky.top/categories/index.html","excerpt":"","text":""},{"title":"欢迎访问以下优秀博客","date":"2020-05-08T06:32:27.913Z","updated":"2020-05-08T06:32:27.913Z","comments":true,"path":"friends/index.html","permalink":"http://yc-sky.top/friends/index.html","excerpt":"","text":"各位大佬想交换友链的话可以在下方留言，须要提供名称、头像和链接。 名称: yc2hang头像: https://cdn.jsdelivr.net/gh/yc2hang/cdn-assets/avatar/avatar.png链接: https://yc-sky.top"},{"title":"关于","date":"2020-05-09T02:18:23.038Z","updated":"2020-05-09T02:18:23.038Z","comments":true,"path":"about/index.html","permalink":"http://yc-sky.top/about/index.html","excerpt":"","text":"About来自武汉的一枚coding菜鸟，现就读于浙工大，本博客主要记录自己学习及工作过程中遇到的问题及一些零碎的知识点，方便以后查看及巩固"},{"title":"所有标签","date":"2020-05-08T03:23:49.890Z","updated":"2020-05-08T03:23:49.890Z","comments":true,"path":"tags/index.html","permalink":"http://yc-sky.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"leetcode 2020.06.12 739. 每日温度","slug":"leetcode-2020-06-12-739-每日温度","date":"2020-06-11T16:29:21.000Z","updated":"2020-06-11T16:36:04.276Z","comments":true,"path":"2020/06/12/leetcode-2020-06-12-739-每日温度/","link":"","permalink":"http://yc-sky.top/2020/06/12/leetcode-2020-06-12-739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/","excerpt":"描述： 根据每日 气温 列表，请重新生成一个列表，对应位置的输出是需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。 例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。 提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。","text":"描述： 根据每日 气温 列表，请重新生成一个列表，对应位置的输出是需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。 例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。 提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。 题解1： 暴力法，双层循环，细节见以下代码 代码： 1234567891011121314151617181920212223/** * @param &#123;number[]&#125; T * @return &#123;number[]&#125; */var dailyTemperatures = function(T) &#123; let stack = [] T.forEach((item,index,arr) =&gt; &#123; let count = 0 for(let i=index;i&lt;arr.length-1;i++)&#123; if(arr[i+1]&gt;item)&#123; count++ stack.push(count) break &#125;else&#123; count++ &#125; &#125; if(!stack[index])&#123; stack.push(0) &#125; &#125;) return stack&#125;; 题解2： 使用单调栈，在遍历的同时使用辅助栈存取数据的索引，然后对比上一个元素的大小，小于上一个元素，则继续入栈，大于则出栈，并得到索引之差放入结果数组中。 代码： 1234567891011class Solution: def dailyTemperatures(self, T: List[int]) -&gt; List[int]: res = [0]*len(T) stack = [] for i in range(len(T)): while len(stack)!=0 and T[i]&gt;T[stack[-1]]: top = stack.pop() res[top] = i - top stack.append(i) return res","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yc-sky.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"单调栈","slug":"单调栈","permalink":"http://yc-sky.top/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"}]},{"title":"leetcode 2020.05.18 152. 乘积最大子数组","slug":"leetcode-2020-05-18-152-乘积最大子数组","date":"2020-05-18T02:33:00.000Z","updated":"2020-05-18T02:39:32.518Z","comments":true,"path":"2020/05/18/leetcode-2020-05-18-152-乘积最大子数组/","link":"","permalink":"http://yc-sky.top/2020/05/18/leetcode-2020-05-18-152-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/","excerpt":"描述： 给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。","text":"描述： 给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。 示例1： 输入: [2,3,-2,4]输出: 6解释: 子数组 [2,3] 有最大乘积 6。 示例2： 输入: [-2,0,-1]输出: 0解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。 题解1： 暴力循环时间复杂度O(n^2) 代码： 12345678910111213141516/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var maxProduct = function(nums) &#123; let temp = [] let max = nums[0] for(let i=0;i&lt;nums.length;i++)&#123; let sum = 1 for(let j=i;j&lt;nums.length;j++)&#123; sum*=nums[j] max = Math.max(sum, max) &#125; &#125; return max&#125;; 题解2： 使用动态规划，遍历一次数组，不断将最大值与当前值比较，最后保存最大值；需要注意的是，当当前项小于零时，将最大值与最小值交换位置 代码： 123456789101112131415161718192021/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var maxProduct = function(nums) &#123; let imax = 1 let imin = 1 let max = nums[0] for(let i=0;i&lt;nums.length;i++)&#123; if(nums[i]&lt;0)&#123; let temp = null temp = imin imin = imax imax = temp &#125; imin = Math.min(imin*nums[i], nums[i]) imax = Math.max(imax*nums[i], nums[i]) max = Math.max(max, imax) &#125; return max&#125;; 代码： 12345678910111213class Solution: def maxProduct(self, nums: List[int]) -&gt; int: imin,imax,mymax = 1,1,nums[0] for i in nums: if i &lt; 0: tmp = None tmp = imin imin = imax imax = tmp imin = min(imin*i, i) imax = max(imax*i, i) mymax = max(imax, mymax) return mymax","categories":[{"name":"算法","slug":"算法","permalink":"http://yc-sky.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yc-sky.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode 2020.05.14 136. 只出现一次的数字","slug":"leetcode-2020-05-14-136-只出现一次的数字","date":"2020-05-14T08:30:25.000Z","updated":"2020-05-15T01:38:57.483Z","comments":true,"path":"2020/05/14/leetcode-2020-05-14-136-只出现一次的数字/","link":"","permalink":"http://yc-sky.top/2020/05/14/leetcode-2020-05-14-136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/","excerpt":"描述： 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。","text":"描述： 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 示例： 输入: [2,2,1]输出: 1输入: [4,1,2,1,2]输出: 4 题解1： 使用异或 任何数和 00 做异或运算，结果仍然是原来的数，即 a \\oplus 0=aa⊕0=a。 任何数和其自身做异或运算，结果是 00，即 a \\oplus a=0a⊕a=0。 异或运算满足交换律和结合律，即 a \\oplus b \\oplus a=b \\oplus a \\oplus a=b \\oplus (a \\oplus a)=b \\oplus0=ba⊕b⊕a=b⊕a⊕a=b⊕(a⊕a)=b⊕0=b。 代码： 123456class Solution: def singleNumber(self, nums: List[int]) -&gt; int: ans = 0 for num in nums: ans^=num return ans 1234567var singleNumber = function(nums) &#123; var ans = 0 for(let num of nums)&#123; ans^=num &#125; return ans&#125;; 题解2： 使用哈希表 Map对象 代码： 12345678910111213141516/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var singleNumber = function(nums) &#123; let myMap = new Map() for(let i=0;i&lt;nums.length;i++)&#123; if(myMap.has(nums[i]))&#123; myMap.delete(nums[i]) continue &#125;else&#123; myMap.set(nums[i],i) &#125; &#125; return myMap.keys().next().value&#125;;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yc-sky.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"位运算","slug":"位运算","permalink":"http://yc-sky.top/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"哈希","slug":"哈希","permalink":"http://yc-sky.top/tags/%E5%93%88%E5%B8%8C/"}]},{"title":"leetcode 2020.05.13 102. 二叉树的层序遍历","slug":"leetcode-2020-05-13-102-二叉树的层序遍历","date":"2020-05-14T01:33:36.000Z","updated":"2020-05-15T01:36:43.300Z","comments":true,"path":"2020/05/14/leetcode-2020-05-13-102-二叉树的层序遍历/","link":"","permalink":"http://yc-sky.top/2020/05/14/leetcode-2020-05-13-102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/","excerpt":"描述： 给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。","text":"描述： 给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。 示例： 二叉树：[3,9,20,null,null,15,7],返回其层次遍历结果：[ [3], [9,20], [15,7]] 题解1： DFS,使用递归，定义一个level，每层+1。 代码： 12345678910111213141516171819202122# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def levelOrder(self, root: TreeNode) -&gt; List[List[int]]: if not root: return [] result = [] def add_to_result(level, node): if level&gt;len(result)-1: #每层先加一个空数组容器 result.append([]) result[level].append(node.val) if node.left: add_to_result(level+1, node.left) if node.right: add_to_result(level+1,node.right) add_to_result(0, root) return result 1234567891011121314151617181920/** * @param &#123;TreeNode&#125; root * @return &#123;number[][]&#125; */var levelOrder = function(root) &#123; if(!root) return [] var result = [] var add_to_result = function(level, node)&#123; if(level&gt;result.length-1) result.push([]) result[level].push(node.val) if(node.left)&#123; add_to_result(level+1, node.left) &#125; if(node.right)&#123; add_to_result(level+1, node.right) &#125; &#125; add_to_result(0, root) return result&#125;; 题解2： BFS总结一下 BFS 的几个主要步骤：1.肯定会用到 deque 的结构用来模拟队列，BFS精髓也在这里。2.队列里肯定是有一个初始点3.然后每次处理从队列中出队一个元素4.对元素进行扩张(具体如何扩张需要根据题目要求)5.对于扩张后满足某条件的点再进行处理，根据需要进入队列，进入队列的点就是扩到下一层的点(不同题目需要处理的方法不同，大家灵活运用)6.然后接着循环处理 deque 中的元素，直到 deque 为空，则代表所有点都已经完成扩张7.最后根据题目要求输出结果(当然这已经不属于 BFS 模板的范围了)所有 BFS 的模板题都大致是这个思路，只不过是可能有小的变形。 代码： 123456789101112131415161718192021222324252627282930# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def levelOrder(self, root: TreeNode) -&gt; List[List[int]]: if not root: return [] from collections import deque quene = deque() quene.append(root) result = [] while len(quene): layer = [] q_len = len(quene) for _ in range(q_len): node = quene.popleft() layer.append(node.val) if node.left: quene.append(node.left) if node.right: quene.append(node.right) q_len-= 1 result.append(layer) return result 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number[][]&#125; */var levelOrder = function(root) &#123; if(!root) return [] var result = [] var quene = [root] while(quene.length)&#123; var len = quene.length var layer = [] while(len)&#123; var node = quene.shift() layer.push(node.val) if(node.left)&#123; quene.push(node.left) &#125; if(node.right)&#123; quene.push(node.right) &#125; len-- &#125; result.push(layer) &#125; return result&#125;;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yc-sky.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"递归","slug":"递归","permalink":"http://yc-sky.top/tags/%E9%80%92%E5%BD%92/"}]},{"title":"leetcode 2020.05.11 50. Pow(x, n)","slug":"leetcode-2020-05-11-50-Pow-x-n","date":"2020-05-11T02:17:24.000Z","updated":"2020-05-11T02:24:44.852Z","comments":true,"path":"2020/05/11/leetcode-2020-05-11-50-Pow-x-n/","link":"","permalink":"http://yc-sky.top/2020/05/11/leetcode-2020-05-11-50-Pow-x-n/","excerpt":"描述： 实现 pow(x, n) ，即计算 x 的 n 次幂函数。","text":"描述： 实现 pow(x, n) ，即计算 x 的 n 次幂函数。 示例1： 输入: 2.00000, 10输出: 1024.00000 示例2： 输入: 2.10000, 3输出: 9.26100 示例3： 输入: 2.00000, -2输出: 0.25000解释: 2-2 = 1/2^2 = 1/4 = 0.25 说明： -100.0 &lt; x &lt; 100.0n 是 32 位有符号整数，其数值范围是 [−2^31, 2^31 − 1] 。 题解： 递归，思路就是减半计算,再递归调用函数，对每一半进行pow计算。 代码： 1234567891011121314151617181920# Definition for a binary tree node.class Solution: def myPow(self, x: float, n: int) -&gt; float: if n == 0: return 1 if n == 1: return x if n &lt; 0: n = -n half = self.myPow(x, n // 2) # 注意，这里用地板除法 if n % 2 == 0: return 1 / (half * half) # 这里注意用算数的除法 else: return 1 / (half * half * x) else: half = self.myPow(x, n // 2) if n % 2 == 0: return half * half else: return half * half * x 1234567891011121314151617181920212223242526/** * @param &#123;number&#125; x * @param &#123;number&#125; n * @return &#123;number&#125; */var myPow = function(x, n) &#123; if(n===0) return 1 if(n===1) return x if(n%2===0)&#123; if(n&gt;0)&#123; half = myPow(x, Math.floor(n/2)) return half*half &#125;else&#123; half = myPow(x, Math.floor(-n/2)) return 1/(half*half) &#125; &#125;else&#123; if(n&gt;0)&#123; half = myPow(x, Math.floor(n/2)) return half*half*x &#125;else&#123; half = myPow(x, Math.floor(-n/2)) return 1/(half*half*x) &#125; &#125;&#125;;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yc-sky.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"递归","slug":"递归","permalink":"http://yc-sky.top/tags/%E9%80%92%E5%BD%92/"},{"name":"位运算","slug":"位运算","permalink":"http://yc-sky.top/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"leetcode 108. 将有序数组转换为二叉搜索树","slug":"leetcode-108-将有序数组转换为二叉搜索树","date":"2020-05-09T07:47:46.000Z","updated":"2020-05-09T09:45:01.314Z","comments":true,"path":"2020/05/09/leetcode-108-将有序数组转换为二叉搜索树/","link":"","permalink":"http://yc-sky.top/2020/05/09/leetcode-108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","excerpt":"描述： 将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。","text":"描述： 将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。 示例： 给定有序数组: [-10,-3,0,5,9], 一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树： 0 / \\ -3 9 / / -10 5 题解： 因为数组为有序的，题目要求为平衡二叉树，所以我们首先将数组中间的数字作为跟节点，将左边的数组放入左子节点，将右边数组放入右子节点，然后递归遍历左右数组，最后返回整个分类好的节点。 代码： 1234567891011121314151617# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def sortedArrayToBST(self, nums: List[int]) -&gt; TreeNode: if not nums: return None mid = len(nums)//2 root = TreeNode(nums[mid]) root.left = self.sortedArrayToBST(nums[:mid]) root.right = self.sortedArrayToBST(nums[mid+1:]) return root","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yc-sky.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"http://yc-sky.top/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-05-07T07:24:10.236Z","updated":"2020-05-08T14:46:04.682Z","comments":true,"path":"2020/05/07/hello-world/","link":"","permalink":"http://yc-sky.top/2020/05/07/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yc-sky.top/tags/Hexo/"}]}],"categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yc-sky.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://yc-sky.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"单调栈","slug":"单调栈","permalink":"http://yc-sky.top/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yc-sky.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"位运算","slug":"位运算","permalink":"http://yc-sky.top/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"哈希","slug":"哈希","permalink":"http://yc-sky.top/tags/%E5%93%88%E5%B8%8C/"},{"name":"递归","slug":"递归","permalink":"http://yc-sky.top/tags/%E9%80%92%E5%BD%92/"},{"name":"二叉树","slug":"二叉树","permalink":"http://yc-sky.top/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yc-sky.top/tags/Hexo/"}]}